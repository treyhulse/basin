
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-rbac-api/cmd/main.go (0.0%)</option>
				
				<option value="file1">go-rbac-api/internal/api/auth.go (0.0%)</option>
				
				<option value="file2">go-rbac-api/internal/api/items.go (0.0%)</option>
				
				<option value="file3">go-rbac-api/internal/config/env.go (0.0%)</option>
				
				<option value="file4">go-rbac-api/internal/db/postgres.go (0.0%)</option>
				
				<option value="file5">go-rbac-api/internal/db/sqlc/db.go (0.0%)</option>
				
				<option value="file6">go-rbac-api/internal/db/sqlc/query.sql.go (0.0%)</option>
				
				<option value="file7">go-rbac-api/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file8">go-rbac-api/internal/models/user.go (0.0%)</option>
				
				<option value="file9">go-rbac-api/internal/rbac/policies.go (0.0%)</option>
				
				<option value="file10">go-rbac-api/internal/schema/manager.go (0.0%)</option>
				
				<option value="file11">go-rbac-api/scripts/hash_password.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "go-rbac-api/internal/api"
        "go-rbac-api/internal/config"
        "go-rbac-api/internal/db"
        "go-rbac-api/internal/middleware"

        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        // Set Gin mode
        <span class="cov0" title="0">gin.SetMode(cfg.ServerMode)

        // Initialize database
        database, err := db.NewDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // Initialize handlers
        authHandler := api.NewAuthHandler(database, cfg)
        itemsHandler := api.NewItemsHandler(database)

        // Setup router
        router := gin.Default()

        // Add CORS middleware
        router.Use(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })

        // Health check endpoint
        <span class="cov0" title="0">router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status": "ok",
                        "time":   time.Now().UTC(),
                })
        }</span>)

        // Auth routes
        <span class="cov0" title="0">auth := router.Group("/auth")
        </span><span class="cov0" title="0">{
                auth.POST("/login", authHandler.Login)
                auth.GET("/me", middleware.AuthMiddleware(cfg, database), authHandler.Me)
        }</span>

        // Items routes (protected)
        <span class="cov0" title="0">items := router.Group("/items")
        items.Use(middleware.AuthMiddleware(cfg, database))
        </span><span class="cov0" title="0">{
                items.GET("/:table", itemsHandler.GetItems)
                items.GET("/:table/:id", itemsHandler.GetItem)
                items.POST("/:table", itemsHandler.CreateItem)
                items.PUT("/:table/:id", itemsHandler.UpdateItem)
                items.DELETE("/:table/:id", itemsHandler.DeleteItem)
        }</span>

        // API documentation
        <span class="cov0" title="0">router.GET("/", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "message": "Go RBAC API - Directus-style API with Role-Based Access Control",
                        "version": "1.0.0",
                        "endpoints": gin.H{
                                "health": "/health",
                                "auth": gin.H{
                                        "login": "POST /auth/login",
                                        "me":    "GET /auth/me",
                                },
                                "items": gin.H{
                                        "list":   "GET /items/:table",
                                        "get":    "GET /items/:table/:id",
                                        "create": "POST /items/:table",
                                        "update": "PUT /items/:table/:id",
                                        "delete": "DELETE /items/:table/:id",
                                },
                        },
                        "sample_tables": []string{"products", "customers", "orders"},
                        "default_admin": gin.H{
                                "email":    "admin@example.com",
                                "password": "password",
                        },
                })
        }</span>)

        // Create server
        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.ServerPort),
                Handler: router,
        }

        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("Starting server on port %d", cfg.ServerPort)
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Println("Shutting down server...")

        // Give outstanding requests a deadline for completion
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown:", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "net/http"

        "go-rbac-api/internal/config"
        "go-rbac-api/internal/db"
        "go-rbac-api/internal/middleware"
        "go-rbac-api/internal/models"

        "github.com/gin-gonic/gin"
)

type AuthHandler struct {
        db  *db.DB
        cfg *config.Config
}

func NewAuthHandler(db *db.DB, cfg *config.Config) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                db:  db,
                cfg: cfg,
        }
}</span>

// Login handles POST /auth/login requests
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var loginReq models.LoginRequest
        if err := c.ShouldBindJSON(&amp;loginReq); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        // Get user from database
        <span class="cov0" title="0">user, err := h.db.Queries.GetUserByEmail(c.Request.Context(), loginReq.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        // Check if user is active
        <span class="cov0" title="0">if !user.IsActive.Bool </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Account is disabled"})
                return
        }</span>

        // Verify password
        <span class="cov0" title="0">if !models.CheckPassword(loginReq.Password, user.PasswordHash) </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        // Generate JWT token
        <span class="cov0" title="0">token, err := middleware.GenerateToken(models.User{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName.String,
                LastName:  user.LastName.String,
                IsActive:  user.IsActive.Bool,
                CreatedAt: user.CreatedAt.Time,
                UpdatedAt: user.UpdatedAt.Time,
        }, h.cfg)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
                return
        }</span>

        // Return response
        <span class="cov0" title="0">c.JSON(http.StatusOK, models.LoginResponse{
                Token: token,
                User: models.User{
                        ID:        user.ID,
                        Email:     user.Email,
                        FirstName: user.FirstName.String,
                        LastName:  user.LastName.String,
                        IsActive:  user.IsActive.Bool,
                        CreatedAt: user.CreatedAt.Time,
                        UpdatedAt: user.UpdatedAt.Time,
                },
        })</span>
}

// Me handles GET /auth/me requests to get current user info
func (h *AuthHandler) Me(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Get user from database
        <span class="cov0" title="0">user, err := h.db.Queries.GetUserByID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.User{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName.String,
                LastName:  user.LastName.String,
                IsActive:  user.IsActive.Bool,
                CreatedAt: user.CreatedAt.Time,
                UpdatedAt: user.UpdatedAt.Time,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go-rbac-api/internal/db"
        sqlc "go-rbac-api/internal/db/sqlc"
        "go-rbac-api/internal/middleware"
        "go-rbac-api/internal/rbac"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/sqlc-dev/pqtype"
)

type ItemsHandler struct {
        db            *db.DB
        policyChecker *rbac.PolicyChecker
}

func NewItemsHandler(db *db.DB) *ItemsHandler <span class="cov0" title="0">{
        return &amp;ItemsHandler{
                db:            db,
                policyChecker: rbac.NewPolicyChecker(db.Queries),
        }
}</span>

// GetItems handles GET /items/:table requests with RBAC filtering
func (h *ItemsHandler) GetItems(c *gin.Context) <span class="cov0" title="0">{
        tableName := c.Param("table")

        // Validate table name
        if !rbac.ValidateTableName(tableName) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid table name"})
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">hasPermission, allowedFields, err := h.policyChecker.CheckPermission(c.Request.Context(), userID, tableName, "read")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permissions"})
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                return
        }</span>

        // Handle schema management tables specially
        <span class="cov0" title="0">if tableName == "collections" || tableName == "fields" || tableName == "users" || tableName == "roles" || tableName == "permissions" || tableName == "api_keys" </span><span class="cov0" title="0">{
                // These are schema tables - use direct queries with tenant filtering
                query := rbac.BuildSelectQuery(tableName, allowedFields)

                var queryParams []interface{}
                var whereConditions []string
                paramIndex := 1

                // Only add tenant filtering for tables that have tenant_id column
                if tableName == "api_keys" </span><span class="cov0" title="0">{
                        // API keys table doesn't have tenant_id, filter by user_id instead
                        whereConditions = append(whereConditions, fmt.Sprintf("user_id = $%d", paramIndex))
                        queryParams = append(queryParams, userID)
                        paramIndex++
                }</span> else<span class="cov0" title="0"> {
                        // Add tenant filtering for multi-tenant support
                        userTenantID, err := h.getUserTenantID(c.Request.Context(), userID)
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user tenant"})
                                return
                        }</span>

                        <span class="cov0" title="0">if userTenantID != uuid.Nil </span><span class="cov0" title="0">{
                                whereConditions = append(whereConditions, fmt.Sprintf("tenant_id = $%d", paramIndex))
                                queryParams = append(queryParams, userTenantID)
                                paramIndex++
                        }</span>
                }

                // Add query parameter filtering
                <span class="cov0" title="0">queryValues := c.Request.URL.Query()
                for key, values := range queryValues </span><span class="cov0" title="0">{
                        if len(values) &gt; 0 &amp;&amp; values[0] != "" </span><span class="cov0" title="0">{
                                // Check if this field is allowed
                                if contains(allowedFields, key) </span><span class="cov0" title="0">{
                                        whereConditions = append(whereConditions, fmt.Sprintf("%s = $%d", key, paramIndex))
                                        queryParams = append(queryParams, values[0])
                                        paramIndex++
                                }</span>
                        }
                }

                // Add WHERE clause if we have conditions
                <span class="cov0" title="0">if len(whereConditions) &gt; 0 </span><span class="cov0" title="0">{
                        query += " WHERE " + strings.Join(whereConditions, " AND ")
                }</span>

                <span class="cov0" title="0">rows, err := h.db.Query(query, queryParams...)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch data"})
                        return
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                // Process results (existing logic)
                results := h.scanRowsToMaps(rows)
                filteredResults := make([]map[string]interface{}, len(results))
                for i, result := range results </span><span class="cov0" title="0">{
                        filteredResults[i] = h.policyChecker.FilterFields(result, allowedFields)
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "data": filteredResults,
                        "meta": gin.H{
                                "table": tableName,
                                "count": len(filteredResults),
                                "type":  "schema",
                        },
                })
                return</span>
        }

        // Handle dynamic data tables with tenant support
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user tenant"})
                return
        }</span>

        // Get tenant schema
        <span class="cov0" title="0">tenantSchema, err := h.getTenantSchema(c.Request.Context(), userTenantID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get tenant schema"})
                return
        }</span>

        <span class="cov0" title="0">dataTableName := tenantSchema + ".data_" + tableName

        // Set user context for RLS
        _, err = h.db.Exec("SELECT set_user_context($1)", userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to set user context"})
                return
        }</span>

        // Check if the data table exists
        <span class="cov0" title="0">tableExists, err := h.tableExists(dataTableName)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check table existence"})
                return
        }</span>

        <span class="cov0" title="0">if !tableExists </span><span class="cov0" title="0">{
                // Table doesn't exist - return empty result or create it
                c.JSON(http.StatusOK, gin.H{
                        "data": []map[string]interface{}{},
                        "meta": gin.H{
                                "table":   tableName,
                                "count":   0,
                                "type":    "data",
                                "message": "Table does not exist yet",
                        },
                })
                return
        }</span>

        // Build query based on allowed fields for data table
        <span class="cov0" title="0">query := rbac.BuildSelectQueryWithTenant(tenantSchema, tableName, allowedFields)

        // Execute query
        rows, err := h.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch data"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Process results
        results := h.scanRowsToMaps(rows)
        filteredResults := make([]map[string]interface{}, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                filteredResults[i] = h.policyChecker.FilterFields(result, allowedFields)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": filteredResults,
                "meta": gin.H{
                        "table": tableName,
                        "count": len(filteredResults),
                        "type":  "data",
                },
        })</span>
}

// Helper method to scan rows to maps (extracted from existing logic)
func (h *ItemsHandler) scanRowsToMaps(rows *sql.Rows) []map[string]interface{} <span class="cov0" title="0">{
        // Get column names
        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var results []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                // Create a slice of interface{} to hold the values
                values := make([]interface{}, len(columns))
                valuePtrs := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                // Scan the row
                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert to map
                <span class="cov0" title="0">row := make(map[string]interface{})
                for i, col := range columns </span><span class="cov0" title="0">{
                        val := values[i]
                        if val != nil </span><span class="cov0" title="0">{
                                // Handle specific types
                                switch v := val.(type) </span>{
                                case []byte:<span class="cov0" title="0">
                                        // Try to unmarshal as JSON, fallback to string
                                        var jsonVal interface{}
                                        if err := json.Unmarshal(v, &amp;jsonVal); err == nil </span><span class="cov0" title="0">{
                                                row[col] = jsonVal
                                        }</span> else<span class="cov0" title="0"> {
                                                row[col] = string(v)
                                        }</span>
                                default:<span class="cov0" title="0">
                                        row[col] = v</span>
                                }
                        } else<span class="cov0" title="0"> {
                                row[col] = nil
                        }</span>
                }

                <span class="cov0" title="0">results = append(results, row)</span>
        }

        <span class="cov0" title="0">return results</span>
}

// Helper method to check if table exists
func (h *ItemsHandler) tableExists(tableName string) (bool, error) <span class="cov0" title="0">{
        query := `
                SELECT EXISTS (
                        SELECT FROM information_schema.tables 
                        WHERE table_schema = split_part($1, '.', 1)
                        AND table_name = split_part($1, '.', 2)
                )
        `
        var exists bool
        err := h.db.QueryRow(query, tableName).Scan(&amp;exists)
        return exists, err
}</span>

// GetItem handles GET /items/:table/:id requests
func (h *ItemsHandler) GetItem(c *gin.Context) <span class="cov0" title="0">{
        tableName := c.Param("table")
        itemID := c.Param("id")

        // Validate table name
        if !rbac.ValidateTableName(tableName) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid table name"})
                return
        }</span>

        // Validate item ID
        <span class="cov0" title="0">if _, err := uuid.Parse(itemID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">hasPermission, allowedFields, err := h.policyChecker.CheckPermission(c.Request.Context(), userID, tableName, "read")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permissions"})
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                return
        }</span>

        // Build query with WHERE clause
        <span class="cov0" title="0">query := rbac.BuildSelectQuery(tableName, allowedFields) + " WHERE id = $1"

        // Execute query
        rows, err := h.db.Query(query, itemID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch item"})
                return
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
                return
        }</span>

        // Get column names
        <span class="cov0" title="0">columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get columns"})
                return
        }</span>

        // Scan the single row
        <span class="cov0" title="0">values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values </span><span class="cov0" title="0">{
                valuePtrs[i] = &amp;values[i]
        }</span>

        <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to scan row"})
                return
        }</span>

        // Convert to map
        <span class="cov0" title="0">row := make(map[string]interface{})
        for i, col := range columns </span><span class="cov0" title="0">{
                val := values[i]
                if val != nil </span><span class="cov0" title="0">{
                        switch v := val.(type) </span>{
                        case []byte:<span class="cov0" title="0">
                                var jsonVal interface{}
                                if err := json.Unmarshal(v, &amp;jsonVal); err == nil </span><span class="cov0" title="0">{
                                        row[col] = jsonVal
                                }</span> else<span class="cov0" title="0"> {
                                        row[col] = string(v)
                                }</span>
                        default:<span class="cov0" title="0">
                                row[col] = v</span>
                        }
                } else<span class="cov0" title="0"> {
                        row[col] = nil
                }</span>
        }

        // Apply field filtering
        <span class="cov0" title="0">filteredRow := h.policyChecker.FilterFields(row, allowedFields)

        c.JSON(http.StatusOK, gin.H{
                "data": filteredRow,
                "meta": gin.H{
                        "table": tableName,
                        "id":    itemID,
                },
        })</span>
}

// CreateItem handles POST /items/:table requests
func (h *ItemsHandler) CreateItem(c *gin.Context) <span class="cov0" title="0">{
        tableName := c.Param("table")

        // Validate table name
        if !rbac.ValidateTableName(tableName) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid table name"})
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">hasPermission, allowedFields, err := h.policyChecker.CheckPermission(c.Request.Context(), userID, tableName, "create")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permissions"})
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var requestData map[string]interface{}
        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        // Filter fields based on permissions
        <span class="cov0" title="0">filteredData := h.policyChecker.FilterFields(requestData, allowedFields)

        // Handle schema tables specially - use sqlc queries
        if tableName == "collections" </span><span class="cov0" title="0">{
                collection, err := h.createCollection(c.Request.Context(), userID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create collection: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "data": collection,
                        "meta": gin.H{
                                "table": tableName,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "fields" </span><span class="cov0" title="0">{
                field, err := h.createField(c.Request.Context(), userID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create field: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "data": field,
                        "meta": gin.H{
                                "table": tableName,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "users" </span><span class="cov0" title="0">{
                user, err := h.createUser(c.Request.Context(), userID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "data": user,
                        "meta": gin.H{
                                "table": tableName,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "api_keys" </span><span class="cov0" title="0">{
                apiKey, err := h.createAPIKey(c.Request.Context(), userID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create API key: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "data": apiKey,
                        "meta": gin.H{
                                "table": tableName,
                        },
                })
                return</span>
        }

        // For dynamic data tables, insert into the actual table
        <span class="cov0" title="0">err = h.createDynamicItem(c.Request.Context(), userID, tableName, filteredData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create item: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                "data": filteredData,
                "meta": gin.H{
                        "table": tableName,
                },
        })</span>
}

// UpdateItem handles PUT /items/:table/:id requests
func (h *ItemsHandler) UpdateItem(c *gin.Context) <span class="cov0" title="0">{
        tableName := c.Param("table")
        itemID := c.Param("id")

        // Validate table name
        if !rbac.ValidateTableName(tableName) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid table name"})
                return
        }</span>

        // Validate item ID
        <span class="cov0" title="0">if _, err := uuid.Parse(itemID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">hasPermission, allowedFields, err := h.policyChecker.CheckPermission(c.Request.Context(), userID, tableName, "update")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permissions"})
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                return
        }</span>

        // Parse request body
        <span class="cov0" title="0">var requestData map[string]interface{}
        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        // Filter fields based on permissions
        <span class="cov0" title="0">filteredData := h.policyChecker.FilterFields(requestData, allowedFields)

        // Handle schema tables specially - use sqlc queries
        if tableName == "api_keys" </span><span class="cov0" title="0">{
                updatedAPIKey, err := h.updateAPIKey(c.Request.Context(), userID, itemID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update API key: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "data": updatedAPIKey,
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "collections" </span><span class="cov0" title="0">{
                updatedCollection, err := h.updateCollection(c.Request.Context(), userID, itemID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update collection: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "data": updatedCollection,
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "fields" </span><span class="cov0" title="0">{
                updatedField, err := h.updateField(c.Request.Context(), userID, itemID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update field: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "data": updatedField,
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "users" </span><span class="cov0" title="0">{
                updatedUser, err := h.updateUser(c.Request.Context(), userID, itemID, filteredData)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "data": updatedUser,
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        // For dynamic data tables, update in the actual table
        <span class="cov0" title="0">err = h.updateDynamicItem(c.Request.Context(), userID, tableName, itemID, filteredData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update item: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "data": filteredData,
                "meta": gin.H{
                        "table": tableName,
                        "id":    itemID,
                },
        })</span>
}

// DeleteItem handles DELETE /items/:table/:id requests
func (h *ItemsHandler) DeleteItem(c *gin.Context) <span class="cov0" title="0">{
        tableName := c.Param("table")
        itemID := c.Param("id")

        // Validate table name
        if !rbac.ValidateTableName(tableName) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid table name"})
                return
        }</span>

        // Validate item ID
        <span class="cov0" title="0">if _, err := uuid.Parse(itemID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid item ID"})
                return
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, exists := middleware.GetUserID(c)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        // Check permissions
        <span class="cov0" title="0">hasPermission, _, err := h.policyChecker.CheckPermission(c.Request.Context(), userID, tableName, "delete")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check permissions"})
                return
        }</span>

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                return
        }</span>

        // Handle schema tables specially - use sqlc queries
        <span class="cov0" title="0">if tableName == "api_keys" </span><span class="cov0" title="0">{
                err := h.deleteAPIKey(c.Request.Context(), userID, itemID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete API key: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "collections" </span><span class="cov0" title="0">{
                err := h.deleteCollection(c.Request.Context(), userID, itemID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete collection: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "fields" </span><span class="cov0" title="0">{
                err := h.deleteField(c.Request.Context(), userID, itemID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete field: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        <span class="cov0" title="0">if tableName == "users" </span><span class="cov0" title="0">{
                err := h.deleteUser(c.Request.Context(), userID, itemID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "meta": gin.H{
                                "table": tableName,
                                "id":    itemID,
                        },
                })
                return</span>
        }

        // For dynamic data tables, delete from the actual table
        <span class="cov0" title="0">err = h.deleteDynamicItem(c.Request.Context(), userID, tableName, itemID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete item: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "meta": gin.H{
                        "table": tableName,
                        "id":    itemID,
                },
        })</span>
}

// Helper method to get user's tenant ID
func (h *ItemsHandler) getUserTenantID(ctx context.Context, userID uuid.UUID) (uuid.UUID, error) <span class="cov0" title="0">{
        query := `SELECT tenant_id FROM users WHERE id = $1`
        var tenantID uuid.UUID
        err := h.db.QueryRowContext(ctx, query, userID).Scan(&amp;tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>
        <span class="cov0" title="0">return tenantID, nil</span>
}

// Helper method to get tenant schema name
func (h *ItemsHandler) getTenantSchema(ctx context.Context, tenantID uuid.UUID) (string, error) <span class="cov0" title="0">{
        query := `SELECT slug FROM tenants WHERE id = $1`
        var schema string
        err := h.db.QueryRowContext(ctx, query, tenantID).Scan(&amp;schema)
        if err != nil </span><span class="cov0" title="0">{
                return "default", err // Fallback to default schema
        }</span>
        <span class="cov0" title="0">return schema, nil</span>
}

// Helper method to create a collection
func (h *ItemsHandler) createCollection(ctx context.Context, userID uuid.UUID, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get user's tenant
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">collectionID := uuid.New()
        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                if parsedID, err := uuid.Parse(id); err == nil </span><span class="cov0" title="0">{
                        collectionID = parsedID
                }</span>
        }

        // Create collection using sqlc
        <span class="cov0" title="0">collection, err := h.db.Queries.CreateCollection(ctx, sqlc.CreateCollectionParams{
                ID:          collectionID,
                Name:        data["name"].(string),
                DisplayName: sql.NullString{String: getStringFromMap(data, "display_name"), Valid: true},
                Description: sql.NullString{String: getStringFromMap(data, "description"), Valid: true},
                Icon:        sql.NullString{String: getStringFromMap(data, "icon"), Valid: true},
                IsSystem:    sql.NullBool{Bool: getBoolFromMap(data, "is_system"), Valid: true},
                TenantID:    uuid.NullUUID{UUID: userTenantID, Valid: true},
                CreatedBy:   uuid.NullUUID{UUID: userID, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":           collection.ID.String(),
                "name":         collection.Name,
                "display_name": collection.DisplayName.String,
                "description":  collection.Description.String,
                "icon":         collection.Icon.String,
                "is_system":    collection.IsSystem.Bool,
                "tenant_id":    collection.TenantID.UUID.String(),
                "created_by":   collection.CreatedBy.UUID.String(),
                "created_at":   collection.CreatedAt.Time,
                "updated_at":   collection.UpdatedAt.Time,
        }

        return result, nil</span>
}

// Helper method to create a field
func (h *ItemsHandler) createField(ctx context.Context, userID uuid.UUID, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get user's tenant
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">fieldID := uuid.New()
        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                if parsedID, err := uuid.Parse(id); err == nil </span><span class="cov0" title="0">{
                        fieldID = parsedID
                }</span>
        }

        // Parse collection_id
        <span class="cov0" title="0">collectionID, err := uuid.Parse(data["collection_id"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid collection_id")
        }</span>

        // Get collection info to check if it's a system collection
        <span class="cov0" title="0">collection, err := h.db.Queries.GetCollection(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collection not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if collection.TenantID.Valid &amp;&amp; collection.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized: collection not accessible")
        }</span>

        // Create field using sqlc
        <span class="cov0" title="0">field, err := h.db.Queries.CreateField(ctx, sqlc.CreateFieldParams{
                ID:              fieldID,
                CollectionID:    uuid.NullUUID{UUID: collectionID, Valid: true},
                Name:            data["name"].(string),
                DisplayName:     sql.NullString{String: getStringFromMap(data, "display_name"), Valid: true},
                Type:            data["type"].(string),
                IsPrimary:       sql.NullBool{Bool: getBoolFromMap(data, "is_primary"), Valid: true},
                IsRequired:      sql.NullBool{Bool: getBoolFromMap(data, "is_required"), Valid: true},
                IsUnique:        sql.NullBool{Bool: getBoolFromMap(data, "is_unique"), Valid: true},
                DefaultValue:    sql.NullString{String: getStringFromMap(data, "default_value"), Valid: true},
                ValidationRules: pqtype.NullRawMessage{},
                RelationConfig:  pqtype.NullRawMessage{},
                SortOrder:       sql.NullInt32{Int32: int32(getIntFromMap(data, "sort_order")), Valid: true},
                TenantID:        uuid.NullUUID{UUID: userTenantID, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If this is not a system collection, update the data table structure
        <span class="cov0" title="0">if !collection.IsSystem.Bool </span><span class="cov0" title="0">{
                err = h.addColumnToDataTable(ctx, userTenantID, collection.Name, field)
                if err != nil </span><span class="cov0" title="0">{
                        // If we fail to add the column, we should delete the field record to maintain consistency
                        h.db.Queries.DeleteField(ctx, fieldID)
                        return nil, fmt.Errorf("failed to add column to data table: %w", err)
                }</span>
        }

        // Convert to map
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":            field.ID.String(),
                "collection_id": field.CollectionID.UUID.String(),
                "name":          field.Name,
                "display_name":  field.DisplayName.String,
                "type":          field.Type,
                "is_primary":    field.IsPrimary.Bool,
                "is_required":   field.IsRequired.Bool,
                "is_unique":     field.IsUnique.Bool,
                "default_value": field.DefaultValue.String,
                "sort_order":    field.SortOrder.Int32,
                "tenant_id":     field.TenantID.UUID.String(),
                "created_at":    field.CreatedAt.Time,
                "updated_at":    field.UpdatedAt.Time,
        }

        return result, nil</span>
}

// Helper method to create a user
func (h *ItemsHandler) createUser(ctx context.Context, userID uuid.UUID, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get user's tenant
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate ID if not provided
        <span class="cov0" title="0">newUserID := uuid.New()
        if id, ok := data["id"].(string); ok </span><span class="cov0" title="0">{
                if parsedID, err := uuid.Parse(id); err == nil </span><span class="cov0" title="0">{
                        newUserID = parsedID
                }</span>
        }

        // Hash password if provided
        <span class="cov0" title="0">passwordHash := ""
        if password, ok := data["password"].(string); ok </span><span class="cov0" title="0">{
                // You'll need to implement password hashing here
                passwordHash = password // TODO: Hash this properly
        }</span>

        // Create user using sqlc
        <span class="cov0" title="0">user, err := h.db.Queries.CreateUser(ctx, sqlc.CreateUserParams{
                ID:           newUserID,
                Email:        data["email"].(string),
                PasswordHash: passwordHash,
                FirstName:    sql.NullString{String: getStringFromMap(data, "first_name"), Valid: true},
                LastName:     sql.NullString{String: getStringFromMap(data, "last_name"), Valid: true},
                TenantID:     uuid.NullUUID{UUID: userTenantID, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map (don't return password hash)
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":         user.ID.String(),
                "email":      user.Email,
                "first_name": user.FirstName.String,
                "last_name":  user.LastName.String,
                "is_active":  user.IsActive.Bool,
                "tenant_id":  user.TenantID.UUID.String(),
                "created_at": user.CreatedAt.Time,
                "updated_at": user.UpdatedAt.Time,
        }

        return result, nil</span>
}

// Helper method to create dynamic item in data table
func (h *ItemsHandler) createDynamicItem(ctx context.Context, userID uuid.UUID, tableName string, data map[string]interface{}) error <span class="cov0" title="0">{
        // Get tenant schema
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tenantSchema, err := h.getTenantSchema(ctx, userTenantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dataTableName := tenantSchema + ".data_" + tableName

        // Check if table exists
        tableExists, err := h.tableExists(dataTableName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !tableExists </span><span class="cov0" title="0">{
                return fmt.Errorf("table %s does not exist", dataTableName)
        }</span>

        // Build INSERT query dynamically
        <span class="cov0" title="0">var columns []string
        var placeholders []string
        var values []interface{}

        // Add standard columns
        columns = append(columns, "created_by", "updated_by")
        placeholders = append(placeholders, "$1", "$2")
        values = append(values, userID, userID)

        paramIndex := 3
        for key, value := range data </span><span class="cov0" title="0">{
                if key != "id" &amp;&amp; key != "created_at" &amp;&amp; key != "updated_at" </span><span class="cov0" title="0">{
                        columns = append(columns, fmt.Sprintf(`"%s"`, key))
                        placeholders = append(placeholders, fmt.Sprintf("$%d", paramIndex))
                        values = append(values, value)
                        paramIndex++
                }</span>
        }

        <span class="cov0" title="0">query := fmt.Sprintf(
                "INSERT INTO %s (%s) VALUES (%s)",
                dataTableName,
                strings.Join(columns, ", "),
                strings.Join(placeholders, ", "),
        )

        _, err = h.db.ExecContext(ctx, query, values...)
        return err</span>
}

// Helper functions to safely extract values from map
func getStringFromMap(data map[string]interface{}, key string) string <span class="cov0" title="0">{
        if val, ok := data[key]; ok </span><span class="cov0" title="0">{
                if str, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return str
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func getBoolFromMap(data map[string]interface{}, key string) bool <span class="cov0" title="0">{
        if val, ok := data[key]; ok </span><span class="cov0" title="0">{
                if b, ok := val.(bool); ok </span><span class="cov0" title="0">{
                        return b
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getIntFromMap(data map[string]interface{}, key string) int <span class="cov0" title="0">{
        if val, ok := data[key]; ok </span><span class="cov0" title="0">{
                if i, ok := val.(int); ok </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">if f, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        return int(f)
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// Helper method to create an API key
func (h *ItemsHandler) createAPIKey(ctx context.Context, userID uuid.UUID, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Get target user ID (can create API keys for other users if admin)
        targetUserID := userID // Default to current user
        if targetUserStr, ok := data["user_id"].(string); ok </span><span class="cov0" title="0">{
                if parsedID, err := uuid.Parse(targetUserStr); err == nil </span><span class="cov0" title="0">{
                        targetUserID = parsedID
                }</span>
        }

        // Generate a secure API key
        <span class="cov0" title="0">apiKey, err := generateAPIKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate API key: %w", err)
        }</span>

        // Hash the API key for storage
        <span class="cov0" title="0">keyHash := hashAPIKey(apiKey)

        // Set expiration (default 1 year from now, or use provided value)
        expiresAt := time.Now().AddDate(1, 0, 0)
        if expStr, ok := data["expires_at"].(string); ok </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, expStr); err == nil </span><span class="cov0" title="0">{
                        expiresAt = parsedTime
                }</span>
        }

        // Get name for the API key
        <span class="cov0" title="0">name := "API Key"
        if nameStr, ok := data["name"].(string); ok </span><span class="cov0" title="0">{
                name = nameStr
        }</span>

        // Create API key using sqlc
        <span class="cov0" title="0">createdKey, err := h.db.Queries.CreateAPIKey(ctx, sqlc.CreateAPIKeyParams{
                UserID:    targetUserID,
                Name:      name,
                KeyHash:   keyHash,
                ExpiresAt: sql.NullTime{Time: expiresAt, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map (include the plain API key only in creation response)
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":           createdKey.ID.String(),
                "user_id":      createdKey.UserID.String(),
                "name":         createdKey.Name,
                "api_key":      apiKey, // Only returned on creation!
                "is_active":    createdKey.IsActive.Bool,
                "expires_at":   createdKey.ExpiresAt.Time,
                "last_used_at": nil,
                "created_at":   createdKey.CreatedAt.Time,
                "updated_at":   createdKey.UpdatedAt.Time,
        }

        return result, nil</span>
}

// generateAPIKey generates a secure random API key
func generateAPIKey() (string, error) <span class="cov0" title="0">{
        // Generate 32 random bytes
        bytes := make([]byte, 32)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Convert to hex string with prefix
        <span class="cov0" title="0">return "basin_" + hex.EncodeToString(bytes), nil</span>
}

// hashAPIKey creates a SHA-256 hash of the API key for secure storage
func hashAPIKey(apiKey string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(apiKey))
        return hex.EncodeToString(hash[:])
}</span>

// Helper method to update an API key
func (h *ItemsHandler) updateAPIKey(ctx context.Context, userID uuid.UUID, itemID string, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Parse item ID
        apiKeyID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid API key ID: %w", err)
        }</span>

        // Check if user owns this API key (unless admin)
        <span class="cov0" title="0">existingKey, err := h.db.Queries.GetAPIKeyByID(ctx, apiKeyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key not found: %w", err)
        }</span>

        // Only allow users to update their own keys (unless admin)
        <span class="cov0" title="0">if existingKey.UserID != userID </span><span class="cov0" title="0">{
                // Check if user is admin
                hasAdminAccess, _, _ := h.policyChecker.CheckPermission(ctx, userID, "users", "read")
                if !hasAdminAccess </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unauthorized: can only update your own API keys")
                }</span>
        }

        // Extract fields with defaults
        <span class="cov0" title="0">name := existingKey.Name
        if nameVal, ok := data["name"].(string); ok </span><span class="cov0" title="0">{
                name = nameVal
        }</span>

        <span class="cov0" title="0">isActive := existingKey.IsActive.Bool
        if activeVal, ok := data["is_active"].(bool); ok </span><span class="cov0" title="0">{
                isActive = activeVal
        }</span>

        <span class="cov0" title="0">expiresAt := existingKey.ExpiresAt
        if expVal, ok := data["expires_at"].(string); ok </span><span class="cov0" title="0">{
                if parsedTime, err := time.Parse(time.RFC3339, expVal); err == nil </span><span class="cov0" title="0">{
                        expiresAt = sql.NullTime{Time: parsedTime, Valid: true}
                }</span>
        }

        // Update API key using sqlc
        <span class="cov0" title="0">updatedKey, err := h.db.Queries.UpdateAPIKey(ctx, sqlc.UpdateAPIKeyParams{
                ID:        apiKeyID,
                Name:      name,
                IsActive:  sql.NullBool{Bool: isActive, Valid: true},
                ExpiresAt: expiresAt,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map (don't include the actual API key in updates)
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":           updatedKey.ID.String(),
                "user_id":      updatedKey.UserID.String(),
                "name":         updatedKey.Name,
                "is_active":    updatedKey.IsActive.Bool,
                "expires_at":   updatedKey.ExpiresAt.Time,
                "last_used_at": nil,
                "created_at":   updatedKey.CreatedAt.Time,
                "updated_at":   updatedKey.UpdatedAt.Time,
        }

        if updatedKey.LastUsedAt.Valid </span><span class="cov0" title="0">{
                result["last_used_at"] = updatedKey.LastUsedAt.Time
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper method to delete an API key
func (h *ItemsHandler) deleteAPIKey(ctx context.Context, userID uuid.UUID, itemID string) error <span class="cov0" title="0">{
        // Parse item ID
        apiKeyID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid API key ID: %w", err)
        }</span>

        // Check if user owns this API key (unless admin)
        <span class="cov0" title="0">existingKey, err := h.db.Queries.GetAPIKeyByID(ctx, apiKeyID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("API key not found: %w", err)
        }</span>

        // Only allow users to delete their own keys (unless admin)
        <span class="cov0" title="0">if existingKey.UserID != userID </span><span class="cov0" title="0">{
                // Check if user is admin
                hasAdminAccess, _, _ := h.policyChecker.CheckPermission(ctx, userID, "users", "read")
                if !hasAdminAccess </span><span class="cov0" title="0">{
                        return fmt.Errorf("unauthorized: can only delete your own API keys")
                }</span>
        }

        // Delete API key using sqlc
        <span class="cov0" title="0">return h.db.Queries.DeleteAPIKey(ctx, apiKeyID)</span>
}

// Helper method to update a collection
func (h *ItemsHandler) updateCollection(ctx context.Context, userID uuid.UUID, itemID string, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Parse item ID
        collectionID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid collection ID: %w", err)
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get existing collection
        <span class="cov0" title="0">existingCollection, err := h.db.Queries.GetCollection(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collection not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingCollection.TenantID.Valid &amp;&amp; existingCollection.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized: collection not accessible")
        }</span>

        // Extract fields with defaults
        <span class="cov0" title="0">displayName := existingCollection.DisplayName
        if displayVal, ok := data["display_name"].(string); ok </span><span class="cov0" title="0">{
                displayName = sql.NullString{String: displayVal, Valid: true}
        }</span>

        <span class="cov0" title="0">description := existingCollection.Description
        if descVal, ok := data["description"].(string); ok </span><span class="cov0" title="0">{
                description = sql.NullString{String: descVal, Valid: true}
        }</span>

        <span class="cov0" title="0">icon := existingCollection.Icon
        if iconVal, ok := data["icon"].(string); ok </span><span class="cov0" title="0">{
                icon = sql.NullString{String: iconVal, Valid: true}
        }</span>

        // Update collection using sqlc
        <span class="cov0" title="0">updatedCollection, err := h.db.Queries.UpdateCollection(ctx, sqlc.UpdateCollectionParams{
                ID:          collectionID,
                DisplayName: displayName,
                Description: description,
                Icon:        icon,
                UpdatedBy:   uuid.NullUUID{UUID: userID, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":           updatedCollection.ID.String(),
                "name":         updatedCollection.Name,
                "display_name": updatedCollection.DisplayName.String,
                "description":  updatedCollection.Description.String,
                "icon":         updatedCollection.Icon.String,
                "tenant_id":    nil,
                "created_by":   nil,
                "updated_by":   nil,
                "created_at":   updatedCollection.CreatedAt.Time,
                "updated_at":   updatedCollection.UpdatedAt.Time,
        }

        if updatedCollection.TenantID.Valid </span><span class="cov0" title="0">{
                result["tenant_id"] = updatedCollection.TenantID.UUID.String()
        }</span>
        <span class="cov0" title="0">if updatedCollection.CreatedBy.Valid </span><span class="cov0" title="0">{
                result["created_by"] = updatedCollection.CreatedBy.UUID.String()
        }</span>
        <span class="cov0" title="0">if updatedCollection.UpdatedBy.Valid </span><span class="cov0" title="0">{
                result["updated_by"] = updatedCollection.UpdatedBy.UUID.String()
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper method to delete a collection
func (h *ItemsHandler) deleteCollection(ctx context.Context, userID uuid.UUID, itemID string) error <span class="cov0" title="0">{
        // Parse item ID
        collectionID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid collection ID: %w", err)
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get existing collection to check access
        <span class="cov0" title="0">existingCollection, err := h.db.Queries.GetCollection(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("collection not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingCollection.TenantID.Valid &amp;&amp; existingCollection.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized: collection not accessible")
        }</span>

        // Delete collection using sqlc (this will trigger the database trigger to drop the data table)
        <span class="cov0" title="0">return h.db.Queries.DeleteCollection(ctx, collectionID)</span>
}

// Helper method to update a field
func (h *ItemsHandler) updateField(ctx context.Context, userID uuid.UUID, itemID string, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Parse item ID
        fieldID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid field ID: %w", err)
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get existing field
        <span class="cov0" title="0">existingField, err := h.db.Queries.GetField(ctx, fieldID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("field not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingField.TenantID.Valid &amp;&amp; existingField.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized: field not accessible")
        }</span>

        // Extract fields with defaults
        <span class="cov0" title="0">displayName := existingField.DisplayName
        if displayVal, ok := data["display_name"].(string); ok </span><span class="cov0" title="0">{
                displayName = sql.NullString{String: displayVal, Valid: true}
        }</span>

        <span class="cov0" title="0">fieldType := existingField.Type
        if typeVal, ok := data["type"].(string); ok </span><span class="cov0" title="0">{
                fieldType = typeVal
        }</span>

        <span class="cov0" title="0">isPrimary := existingField.IsPrimary
        if primaryVal, ok := data["is_primary"].(bool); ok </span><span class="cov0" title="0">{
                isPrimary = sql.NullBool{Bool: primaryVal, Valid: true}
        }</span>

        <span class="cov0" title="0">isRequired := existingField.IsRequired
        if reqVal, ok := data["is_required"].(bool); ok </span><span class="cov0" title="0">{
                isRequired = sql.NullBool{Bool: reqVal, Valid: true}
        }</span>

        <span class="cov0" title="0">isUnique := existingField.IsUnique
        if uniqueVal, ok := data["is_unique"].(bool); ok </span><span class="cov0" title="0">{
                isUnique = sql.NullBool{Bool: uniqueVal, Valid: true}
        }</span>

        <span class="cov0" title="0">defaultValue := existingField.DefaultValue
        if defVal, ok := data["default_value"].(string); ok </span><span class="cov0" title="0">{
                defaultValue = sql.NullString{String: defVal, Valid: true}
        }</span>

        <span class="cov0" title="0">sortOrder := existingField.SortOrder
        if sortInt := getIntFromMap(data, "sort_order"); sortInt &gt; 0 </span><span class="cov0" title="0">{
                sortOrder = sql.NullInt32{Int32: int32(sortInt), Valid: true}
        }</span>

        // Update field using sqlc
        <span class="cov0" title="0">updatedField, err := h.db.Queries.UpdateField(ctx, sqlc.UpdateFieldParams{
                ID:              fieldID,
                DisplayName:     displayName,
                Type:            fieldType,
                IsPrimary:       isPrimary,
                IsRequired:      isRequired,
                IsUnique:        isUnique,
                DefaultValue:    defaultValue,
                ValidationRules: existingField.ValidationRules,
                RelationConfig:  existingField.RelationConfig,
                SortOrder:       sortOrder,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":            updatedField.ID.String(),
                "collection_id": nil,
                "name":          updatedField.Name,
                "display_name":  updatedField.DisplayName.String,
                "type":          updatedField.Type,
                "is_primary":    updatedField.IsPrimary.Bool,
                "is_required":   updatedField.IsRequired.Bool,
                "is_unique":     updatedField.IsUnique.Bool,
                "default_value": updatedField.DefaultValue.String,
                "sort_order":    updatedField.SortOrder.Int32,
                "tenant_id":     nil,
                "created_at":    updatedField.CreatedAt.Time,
                "updated_at":    updatedField.UpdatedAt.Time,
        }

        if updatedField.CollectionID.Valid </span><span class="cov0" title="0">{
                result["collection_id"] = updatedField.CollectionID.UUID.String()
        }</span>
        <span class="cov0" title="0">if updatedField.TenantID.Valid </span><span class="cov0" title="0">{
                result["tenant_id"] = updatedField.TenantID.UUID.String()
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper method to delete a field
func (h *ItemsHandler) deleteField(ctx context.Context, userID uuid.UUID, itemID string) error <span class="cov0" title="0">{
        // Parse item ID
        fieldID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid field ID: %w", err)
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get existing field to check access
        <span class="cov0" title="0">existingField, err := h.db.Queries.GetField(ctx, fieldID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("field not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingField.TenantID.Valid &amp;&amp; existingField.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized: field not accessible")
        }</span>

        // Delete field using sqlc
        <span class="cov0" title="0">return h.db.Queries.DeleteField(ctx, fieldID)</span>
}

// Helper method to update a user
func (h *ItemsHandler) updateUser(ctx context.Context, userID uuid.UUID, itemID string, data map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        // Parse item ID
        targetUserID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get existing user
        <span class="cov0" title="0">existingUser, err := h.db.Queries.GetUserByID(ctx, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingUser.TenantID.Valid &amp;&amp; existingUser.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unauthorized: user not accessible")
        }</span>

        // Extract fields with defaults
        <span class="cov0" title="0">email := existingUser.Email
        if emailVal, ok := data["email"].(string); ok </span><span class="cov0" title="0">{
                email = emailVal
        }</span>

        <span class="cov0" title="0">firstName := existingUser.FirstName
        if firstVal, ok := data["first_name"].(string); ok </span><span class="cov0" title="0">{
                firstName = sql.NullString{String: firstVal, Valid: true}
        }</span>

        <span class="cov0" title="0">lastName := existingUser.LastName
        if lastVal, ok := data["last_name"].(string); ok </span><span class="cov0" title="0">{
                lastName = sql.NullString{String: lastVal, Valid: true}
        }</span>

        <span class="cov0" title="0">isActive := existingUser.IsActive
        if activeVal, ok := data["is_active"].(bool); ok </span><span class="cov0" title="0">{
                isActive = sql.NullBool{Bool: activeVal, Valid: true}
        }</span>

        // Update user using sqlc
        <span class="cov0" title="0">updatedUser, err := h.db.Queries.UpdateUser(ctx, sqlc.UpdateUserParams{
                ID:        targetUserID,
                Email:     email,
                FirstName: firstName,
                LastName:  lastName,
                IsActive:  isActive,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to map (don't include password hash)
        <span class="cov0" title="0">result := map[string]interface{}{
                "id":         updatedUser.ID.String(),
                "email":      updatedUser.Email,
                "first_name": updatedUser.FirstName.String,
                "last_name":  updatedUser.LastName.String,
                "is_active":  updatedUser.IsActive.Bool,
                "tenant_id":  nil,
                "created_at": updatedUser.CreatedAt.Time,
                "updated_at": updatedUser.UpdatedAt.Time,
        }

        if updatedUser.TenantID.Valid </span><span class="cov0" title="0">{
                result["tenant_id"] = updatedUser.TenantID.UUID.String()
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// Helper method to delete a user
func (h *ItemsHandler) deleteUser(ctx context.Context, userID uuid.UUID, itemID string) error <span class="cov0" title="0">{
        // Parse item ID
        targetUserID, err := uuid.Parse(itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid user ID: %w", err)
        }</span>

        // Prevent self-deletion
        <span class="cov0" title="0">if targetUserID == userID </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot delete your own user account")
        }</span>

        // Get tenant ID for filtering
        <span class="cov0" title="0">userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get existing user to check access
        <span class="cov0" title="0">existingUser, err := h.db.Queries.GetUserByID(ctx, targetUserID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found: %w", err)
        }</span>

        // Check tenant access
        <span class="cov0" title="0">if existingUser.TenantID.Valid &amp;&amp; existingUser.TenantID.UUID != userTenantID </span><span class="cov0" title="0">{
                return fmt.Errorf("unauthorized: user not accessible")
        }</span>

        // Delete user using sqlc
        <span class="cov0" title="0">return h.db.Queries.DeleteUser(ctx, targetUserID)</span>
}

// Helper method to update dynamic item in data table
func (h *ItemsHandler) updateDynamicItem(ctx context.Context, userID uuid.UUID, tableName string, itemID string, data map[string]interface{}) error <span class="cov0" title="0">{
        // Get tenant schema
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tenantSchema, err := h.getTenantSchema(ctx, userTenantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dataTableName := tenantSchema + ".data_" + tableName

        // Check if table exists
        exists, err := h.tableExists(dataTableName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check table existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("table %s does not exist", dataTableName)
        }</span>

        // Set user context for RLS
        <span class="cov0" title="0">_, err = h.db.Exec("SELECT set_user_context($1)", userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set user context: %w", err)
        }</span>

        // Build dynamic UPDATE query
        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no data provided for update")
        }</span>

        <span class="cov0" title="0">setParts := make([]string, 0, len(data))
        args := make([]interface{}, 0, len(data)+1)
        argIndex := 1

        for field, value := range data </span><span class="cov0" title="0">{
                setParts = append(setParts, fmt.Sprintf("%s = $%d", field, argIndex))
                args = append(args, value)
                argIndex++
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("UPDATE %s SET %s, updated_at = CURRENT_TIMESTAMP WHERE id = $%d",
                dataTableName, strings.Join(setParts, ", "), argIndex)
        args = append(args, itemID)

        // Execute update
        result, err := h.db.Exec(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update item: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found or no changes made")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper method to delete dynamic item from data table
func (h *ItemsHandler) deleteDynamicItem(ctx context.Context, userID uuid.UUID, tableName string, itemID string) error <span class="cov0" title="0">{
        // Get tenant schema
        userTenantID, err := h.getUserTenantID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">tenantSchema, err := h.getTenantSchema(ctx, userTenantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dataTableName := tenantSchema + ".data_" + tableName

        // Check if table exists
        exists, err := h.tableExists(dataTableName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check table existence: %w", err)
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("table %s does not exist", dataTableName)
        }</span>

        // Set user context for RLS
        <span class="cov0" title="0">_, err = h.db.Exec("SELECT set_user_context($1)", userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set user context: %w", err)
        }</span>

        // Execute delete
        <span class="cov0" title="0">query := fmt.Sprintf("DELETE FROM %s WHERE id = $1", dataTableName)
        result, err := h.db.Exec(query, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete item: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper function to check if a slice contains a string (handles wildcard *)
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item || s == "*" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Helper method to add a column to a data table when a field is created
func (h *ItemsHandler) addColumnToDataTable(ctx context.Context, tenantID uuid.UUID, collectionName string, field sqlc.Field) error <span class="cov0" title="0">{
        // Get tenant schema
        tenantSchema, err := h.getTenantSchema(ctx, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // For table existence check, use unquoted schema name
        <span class="cov0" title="0">unquotedTableName := tenantSchema + ".data_" + collectionName
        // For ALTER TABLE, use quoted schema name
        quotedTableName := "\"" + tenantSchema + "\".data_" + collectionName

        // Check if table exists
        tableExists, err := h.tableExists(unquotedTableName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !tableExists </span><span class="cov0" title="0">{
                return fmt.Errorf("data table %s does not exist", unquotedTableName)
        }</span>

        // Build ALTER TABLE statement
        <span class="cov0" title="0">var columnType string
        switch field.Type </span>{
        case "text":<span class="cov0" title="0">
                columnType = "TEXT"</span>
        case "number":<span class="cov0" title="0">
                columnType = "NUMERIC"</span>
        case "boolean":<span class="cov0" title="0">
                columnType = "BOOLEAN"</span>
        case "date":<span class="cov0" title="0">
                columnType = "DATE"</span>
        case "datetime":<span class="cov0" title="0">
                columnType = "TIMESTAMP WITH TIME ZONE"</span>
        default:<span class="cov0" title="0">
                columnType = "TEXT"</span>
        }

        // Build the ALTER TABLE query
        <span class="cov0" title="0">alterQuery := fmt.Sprintf(`ALTER TABLE %s ADD COLUMN "%s" %s`, quotedTableName, field.Name, columnType)

        // Add NOT NULL constraint if required
        if field.IsRequired.Bool </span><span class="cov0" title="0">{
                alterQuery += " NOT NULL"
        }</span>

        // Add default value if provided
        <span class="cov0" title="0">if field.DefaultValue.Valid &amp;&amp; field.DefaultValue.String != "" </span><span class="cov0" title="0">{
                alterQuery += fmt.Sprintf(" DEFAULT '%s'", field.DefaultValue.String)
        }</span>

        // Execute the ALTER TABLE statement
        <span class="cov0" title="0">_, err = h.db.ExecContext(ctx, alterQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add column to data table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

type Config struct {
        DBHost     string
        DBPort     int
        DBUser     string
        DBPassword string
        DBName     string
        DBSSLMode  string

        JWTSecret string
        JWTExpiry time.Duration

        ServerPort int
        ServerMode string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        // Load .env file if it exists
        if err := godotenv.Load(".env"); err != nil </span><span class="cov0" title="0">{
                // Log the error but continue with defaults
                fmt.Printf("Warning: Could not load .env file: %v\n", err)
        }</span>

        <span class="cov0" title="0">config := &amp;Config{
                DBHost:     getEnv("DB_HOST", "localhost"),
                DBPort:     getEnvAsInt("DB_PORT", 5432),
                DBUser:     getEnv("DB_USER", "postgres"),
                DBPassword: getEnv("DB_PASSWORD", "postgres"),
                DBName:     getEnv("DB_NAME", "go_rbac_db"),
                DBSSLMode:  getEnv("DB_SSLMODE", "disable"),

                JWTSecret: getEnv("JWT_SECRET", "your-super-secret-jwt-key-change-in-production"),
                JWTExpiry: getEnvAsDuration("JWT_EXPIRY", 24*time.Hour),

                ServerPort: getEnvAsInt("SERVER_PORT", 8080),
                ServerMode: getEnv("SERVER_MODE", "debug"),
        }

        return config, nil</span>
}

func (c *Config) GetDBConnString() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                c.DBHost, c.DBPort, c.DBUser, c.DBPassword, c.DBName, c.DBSSLMode)
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package db

import (
        "database/sql"
        "fmt"
        "log"

        "go-rbac-api/internal/config"
        sqlc "go-rbac-api/internal/db/sqlc"

        _ "github.com/lib/pq"
)

type DB struct {
        *sql.DB
        *sqlc.Queries
}

func NewDB(cfg *config.Config) (*DB, error) <span class="cov0" title="0">{
        connStr := cfg.GetDBConnString()

        db, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Test the connection
        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to database")

        queries := sqlc.New(db)

        return &amp;DB{
                DB:      db,
                Queries: queries,
        }, nil</span>
}

func (db *DB) Close() error <span class="cov0" title="0">{
        return db.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package db

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/lib/pq"
        "github.com/sqlc-dev/pqtype"
)

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (user_id, name, key_hash, expires_at) VALUES ($1, $2, $3, $4) RETURNING id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at
`

type CreateAPIKeyParams struct {
        UserID    uuid.UUID    `json:"user_id"`
        Name      string       `json:"name"`
        KeyHash   string       `json:"key_hash"`
        ExpiresAt sql.NullTime `json:"expires_at"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createAPIKey,
                arg.UserID,
                arg.Name,
                arg.KeyHash,
                arg.ExpiresAt,
        )
        var i ApiKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.KeyHash,
                &amp;i.IsActive,
                &amp;i.ExpiresAt,
                &amp;i.LastUsedAt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (id, name, display_name, description, icon, is_system, tenant_id, created_by) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, name, display_name, description, icon, is_system, created_at, updated_at, tenant_id, created_by, updated_by
`

type CreateCollectionParams struct {
        ID          uuid.UUID      `json:"id"`
        Name        string         `json:"name"`
        DisplayName sql.NullString `json:"display_name"`
        Description sql.NullString `json:"description"`
        Icon        sql.NullString `json:"icon"`
        IsSystem    sql.NullBool   `json:"is_system"`
        TenantID    uuid.NullUUID  `json:"tenant_id"`
        CreatedBy   uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createCollection,
                arg.ID,
                arg.Name,
                arg.DisplayName,
                arg.Description,
                arg.Icon,
                arg.IsSystem,
                arg.TenantID,
                arg.CreatedBy,
        )
        var i Collection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.IsSystem,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
                &amp;i.CreatedBy,
                &amp;i.UpdatedBy,
        )
        return i, err
}</span>

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (first_name, last_name, email, phone, address) VALUES ($1, $2, $3, $4, $5) RETURNING id, first_name, last_name, email, phone, address, created_at, updated_at
`

type CreateCustomerParams struct {
        FirstName string         `json:"first_name"`
        LastName  string         `json:"last_name"`
        Email     string         `json:"email"`
        Phone     sql.NullString `json:"phone"`
        Address   sql.NullString `json:"address"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createCustomer,
                arg.FirstName,
                arg.LastName,
                arg.Email,
                arg.Phone,
                arg.Address,
        )
        var i Customer
        err := row.Scan(
                &amp;i.ID,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Email,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const createField = `-- name: CreateField :one
INSERT INTO fields (id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at, tenant_id
`

type CreateFieldParams struct {
        ID              uuid.UUID             `json:"id"`
        CollectionID    uuid.NullUUID         `json:"collection_id"`
        Name            string                `json:"name"`
        DisplayName     sql.NullString        `json:"display_name"`
        Type            string                `json:"type"`
        IsPrimary       sql.NullBool          `json:"is_primary"`
        IsRequired      sql.NullBool          `json:"is_required"`
        IsUnique        sql.NullBool          `json:"is_unique"`
        DefaultValue    sql.NullString        `json:"default_value"`
        ValidationRules pqtype.NullRawMessage `json:"validation_rules"`
        RelationConfig  pqtype.NullRawMessage `json:"relation_config"`
        SortOrder       sql.NullInt32         `json:"sort_order"`
        TenantID        uuid.NullUUID         `json:"tenant_id"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) (Field, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createField,
                arg.ID,
                arg.CollectionID,
                arg.Name,
                arg.DisplayName,
                arg.Type,
                arg.IsPrimary,
                arg.IsRequired,
                arg.IsUnique,
                arg.DefaultValue,
                arg.ValidationRules,
                arg.RelationConfig,
                arg.SortOrder,
                arg.TenantID,
        )
        var i Field
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CollectionID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Type,
                &amp;i.IsPrimary,
                &amp;i.IsRequired,
                &amp;i.IsUnique,
                &amp;i.DefaultValue,
                &amp;i.ValidationRules,
                &amp;i.RelationConfig,
                &amp;i.SortOrder,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (customer_id, total_amount, notes) VALUES ($1, $2, $3) RETURNING id, customer_id, order_date, status, total_amount, notes, created_at, updated_at
`

type CreateOrderParams struct {
        CustomerID  uuid.NullUUID  `json:"customer_id"`
        TotalAmount string         `json:"total_amount"`
        Notes       sql.NullString `json:"notes"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createOrder, arg.CustomerID, arg.TotalAmount, arg.Notes)
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CustomerID,
                &amp;i.OrderDate,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES ($1, $2, $3, $4) RETURNING id, order_id, product_id, quantity, unit_price, created_at
`

type CreateOrderItemParams struct {
        OrderID   uuid.NullUUID `json:"order_id"`
        ProductID uuid.NullUUID `json:"product_id"`
        Quantity  int32         `json:"quantity"`
        UnitPrice string        `json:"unit_price"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createOrderItem,
                arg.OrderID,
                arg.ProductID,
                arg.Quantity,
                arg.UnitPrice,
        )
        var i OrderItem
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (id, role_id, table_name, action, field_filter, allowed_fields, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id
`

type CreatePermissionParams struct {
        ID            uuid.UUID             `json:"id"`
        RoleID        uuid.NullUUID         `json:"role_id"`
        TableName     string                `json:"table_name"`
        Action        string                `json:"action"`
        FieldFilter   pqtype.NullRawMessage `json:"field_filter"`
        AllowedFields []string              `json:"allowed_fields"`
        TenantID      uuid.NullUUID         `json:"tenant_id"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createPermission,
                arg.ID,
                arg.RoleID,
                arg.TableName,
                arg.Action,
                arg.FieldFilter,
                pq.Array(arg.AllowedFields),
                arg.TenantID,
        )
        var i Permission
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RoleID,
                &amp;i.TableName,
                &amp;i.Action,
                &amp;i.FieldFilter,
                pq.Array(&amp;i.AllowedFields),
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name, description, price, category, stock_quantity) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, description, price, category, stock_quantity, created_at, updated_at
`

type CreateProductParams struct {
        Name          string         `json:"name"`
        Description   sql.NullString `json:"description"`
        Price         string         `json:"price"`
        Category      sql.NullString `json:"category"`
        StockQuantity sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createProduct,
                arg.Name,
                arg.Description,
                arg.Price,
                arg.Category,
                arg.StockQuantity,
        )
        var i Product
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Category,
                &amp;i.StockQuantity,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (id, name, slug, domain, settings) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, slug, domain, settings, is_active, created_at, updated_at
`

type CreateTenantParams struct {
        ID       uuid.UUID             `json:"id"`
        Name     string                `json:"name"`
        Slug     string                `json:"slug"`
        Domain   sql.NullString        `json:"domain"`
        Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createTenant,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Domain,
                arg.Settings,
        )
        var i Tenant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Domain,
                &amp;i.Settings,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, password_hash, first_name, last_name, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, password_hash, first_name, last_name, is_active, created_at, updated_at, tenant_id
`

type CreateUserParams struct {
        ID           uuid.UUID      `json:"id"`
        Email        string         `json:"email"`
        PasswordHash string         `json:"password_hash"`
        FirstName    sql.NullString `json:"first_name"`
        LastName     sql.NullString `json:"last_name"`
        TenantID     uuid.NullUUID  `json:"tenant_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createUser,
                arg.ID,
                arg.Email,
                arg.PasswordHash,
                arg.FirstName,
                arg.LastName,
                arg.TenantID,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE id = $1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteAPIKey, id)
        return err
}</span>

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteCollection, id)
        return err
}</span>

const deleteCustomer = `-- name: DeleteCustomer :exec
DELETE FROM customers WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteCustomer, id)
        return err
}</span>

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields WHERE id = $1
`

func (q *Queries) DeleteField(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteField, id)
        return err
}</span>

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders WHERE id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteOrder, id)
        return err
}</span>

const deleteOrderItem = `-- name: DeleteOrderItem :exec
DELETE FROM order_items WHERE id = $1
`

func (q *Queries) DeleteOrderItem(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteOrderItem, id)
        return err
}</span>

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deletePermission, id)
        return err
}</span>

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteProduct, id)
        return err
}</span>

const deleteTenant = `-- name: DeleteTenant :exec
DELETE FROM tenants WHERE id = $1
`

func (q *Queries) DeleteTenant(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteTenant, id)
        return err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteUser, id)
        return err
}</span>

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one
SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE key_hash = $1 AND is_active = true
`

// API Key Management Queries
func (q *Queries) GetAPIKeyByHash(ctx context.Context, keyHash string) (ApiKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getAPIKeyByHash, keyHash)
        var i ApiKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.KeyHash,
                &amp;i.IsActive,
                &amp;i.ExpiresAt,
                &amp;i.LastUsedAt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE id = $1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
        var i ApiKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.KeyHash,
                &amp;i.IsActive,
                &amp;i.ExpiresAt,
                &amp;i.LastUsedAt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getAPIKeysByUser = `-- name: GetAPIKeysByUser :many
SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetAPIKeysByUser(ctx context.Context, userID uuid.UUID) ([]ApiKey, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getAPIKeysByUser, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []ApiKey{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i ApiKey
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.UserID,
                        &amp;i.Name,
                        &amp;i.KeyHash,
                        &amp;i.IsActive,
                        &amp;i.ExpiresAt,
                        &amp;i.LastUsedAt,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getCollection = `-- name: GetCollection :one
SELECT id, name, display_name, description, icon, is_system, created_at, updated_at, tenant_id, created_by, updated_by FROM collections WHERE id = $1
`

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID) (Collection, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getCollection, id)
        var i Collection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.IsSystem,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
                &amp;i.CreatedBy,
                &amp;i.UpdatedBy,
        )
        return i, err
}</span>

const getCollections = `-- name: GetCollections :many
SELECT id, name, display_name, description, icon, is_system, created_at, updated_at, tenant_id, created_by, updated_by FROM collections ORDER BY name
`

// Schema Management Queries
func (q *Queries) GetCollections(ctx context.Context) ([]Collection, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getCollections)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Collection{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Collection
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.DisplayName,
                        &amp;i.Description,
                        &amp;i.Icon,
                        &amp;i.IsSystem,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                        &amp;i.CreatedBy,
                        &amp;i.UpdatedBy,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, first_name, last_name, email, phone, address, created_at, updated_at FROM customers WHERE id = $1
`

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getCustomer, id)
        var i Customer
        err := row.Scan(
                &amp;i.ID,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Email,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getCustomers = `-- name: GetCustomers :many
SELECT id, first_name, last_name, email, phone, address, created_at, updated_at FROM customers
`

func (q *Queries) GetCustomers(ctx context.Context) ([]Customer, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getCustomers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Customer{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Customer
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.FirstName,
                        &amp;i.LastName,
                        &amp;i.Email,
                        &amp;i.Phone,
                        &amp;i.Address,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getField = `-- name: GetField :one
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at, tenant_id FROM fields WHERE id = $1
`

func (q *Queries) GetField(ctx context.Context, id uuid.UUID) (Field, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getField, id)
        var i Field
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CollectionID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Type,
                &amp;i.IsPrimary,
                &amp;i.IsRequired,
                &amp;i.IsUnique,
                &amp;i.DefaultValue,
                &amp;i.ValidationRules,
                &amp;i.RelationConfig,
                &amp;i.SortOrder,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const getFields = `-- name: GetFields :many
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at, tenant_id FROM fields ORDER BY sort_order
`

func (q *Queries) GetFields(ctx context.Context) ([]Field, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getFields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Field{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Field
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.CollectionID,
                        &amp;i.Name,
                        &amp;i.DisplayName,
                        &amp;i.Type,
                        &amp;i.IsPrimary,
                        &amp;i.IsRequired,
                        &amp;i.IsUnique,
                        &amp;i.DefaultValue,
                        &amp;i.ValidationRules,
                        &amp;i.RelationConfig,
                        &amp;i.SortOrder,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getFieldsByCollection = `-- name: GetFieldsByCollection :many
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at, tenant_id FROM fields WHERE collection_id = $1 ORDER BY sort_order
`

func (q *Queries) GetFieldsByCollection(ctx context.Context, collectionID uuid.NullUUID) ([]Field, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getFieldsByCollection, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Field{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Field
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.CollectionID,
                        &amp;i.Name,
                        &amp;i.DisplayName,
                        &amp;i.Type,
                        &amp;i.IsPrimary,
                        &amp;i.IsRequired,
                        &amp;i.IsUnique,
                        &amp;i.DefaultValue,
                        &amp;i.ValidationRules,
                        &amp;i.RelationConfig,
                        &amp;i.SortOrder,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getOrder = `-- name: GetOrder :one
SELECT id, customer_id, order_date, status, total_amount, notes, created_at, updated_at FROM orders WHERE id = $1
`

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getOrder, id)
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CustomerID,
                &amp;i.OrderDate,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getOrderItem = `-- name: GetOrderItem :one
SELECT id, order_id, product_id, quantity, unit_price, created_at FROM order_items WHERE id = $1
`

func (q *Queries) GetOrderItem(ctx context.Context, id uuid.UUID) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getOrderItem, id)
        var i OrderItem
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, order_id, product_id, quantity, unit_price, created_at FROM order_items
`

func (q *Queries) GetOrderItems(ctx context.Context) ([]OrderItem, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getOrderItems)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []OrderItem{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i OrderItem
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.OrderID,
                        &amp;i.ProductID,
                        &amp;i.Quantity,
                        &amp;i.UnitPrice,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getOrders = `-- name: GetOrders :many
SELECT id, customer_id, order_date, status, total_amount, notes, created_at, updated_at FROM orders
`

func (q *Queries) GetOrders(ctx context.Context) ([]Order, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getOrders)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Order{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Order
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.CustomerID,
                        &amp;i.OrderDate,
                        &amp;i.Status,
                        &amp;i.TotalAmount,
                        &amp;i.Notes,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPermissionsByRole = `-- name: GetPermissionsByRole :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id FROM permissions WHERE role_id = $1
`

func (q *Queries) GetPermissionsByRole(ctx context.Context, roleID uuid.NullUUID) ([]Permission, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getPermissionsByRole, roleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Permission{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Permission
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RoleID,
                        &amp;i.TableName,
                        &amp;i.Action,
                        &amp;i.FieldFilter,
                        pq.Array(&amp;i.AllowedFields),
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPermissionsByRoleAndAction = `-- name: GetPermissionsByRoleAndAction :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id FROM permissions WHERE role_id = $1 AND table_name = $2 AND action = $3
`

type GetPermissionsByRoleAndActionParams struct {
        RoleID    uuid.NullUUID `json:"role_id"`
        TableName string        `json:"table_name"`
        Action    string        `json:"action"`
}

func (q *Queries) GetPermissionsByRoleAndAction(ctx context.Context, arg GetPermissionsByRoleAndActionParams) ([]Permission, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndAction, arg.RoleID, arg.TableName, arg.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Permission{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Permission
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RoleID,
                        &amp;i.TableName,
                        &amp;i.Action,
                        &amp;i.FieldFilter,
                        pq.Array(&amp;i.AllowedFields),
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPermissionsByRoleAndTable = `-- name: GetPermissionsByRoleAndTable :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id FROM permissions WHERE role_id = $1 AND table_name = $2
`

type GetPermissionsByRoleAndTableParams struct {
        RoleID    uuid.NullUUID `json:"role_id"`
        TableName string        `json:"table_name"`
}

func (q *Queries) GetPermissionsByRoleAndTable(ctx context.Context, arg GetPermissionsByRoleAndTableParams) ([]Permission, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndTable, arg.RoleID, arg.TableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Permission{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Permission
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RoleID,
                        &amp;i.TableName,
                        &amp;i.Action,
                        &amp;i.FieldFilter,
                        pq.Array(&amp;i.AllowedFields),
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPermissionsByRoleAndTenant = `-- name: GetPermissionsByRoleAndTenant :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id FROM permissions WHERE role_id = $1 AND tenant_id = $2
`

type GetPermissionsByRoleAndTenantParams struct {
        RoleID   uuid.NullUUID `json:"role_id"`
        TenantID uuid.NullUUID `json:"tenant_id"`
}

// Enhanced Permission Queries with Tenant Support
func (q *Queries) GetPermissionsByRoleAndTenant(ctx context.Context, arg GetPermissionsByRoleAndTenantParams) ([]Permission, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndTenant, arg.RoleID, arg.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Permission{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Permission
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RoleID,
                        &amp;i.TableName,
                        &amp;i.Action,
                        &amp;i.FieldFilter,
                        pq.Array(&amp;i.AllowedFields),
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getPermissionsByUserAndTenant = `-- name: GetPermissionsByUserAndTenant :many
SELECT p.id, p.role_id, p.table_name, p.action, p.field_filter, p.allowed_fields, p.created_at, p.updated_at, p.tenant_id FROM permissions p
JOIN user_roles ur ON p.role_id = ur.role_id
WHERE ur.user_id = $1 AND p.tenant_id = $2
`

type GetPermissionsByUserAndTenantParams struct {
        UserID   uuid.UUID     `json:"user_id"`
        TenantID uuid.NullUUID `json:"tenant_id"`
}

func (q *Queries) GetPermissionsByUserAndTenant(ctx context.Context, arg GetPermissionsByUserAndTenantParams) ([]Permission, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getPermissionsByUserAndTenant, arg.UserID, arg.TenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Permission{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Permission
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RoleID,
                        &amp;i.TableName,
                        &amp;i.Action,
                        &amp;i.FieldFilter,
                        pq.Array(&amp;i.AllowedFields),
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getProduct = `-- name: GetProduct :one
SELECT id, name, description, price, category, stock_quantity, created_at, updated_at FROM products WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getProduct, id)
        var i Product
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Category,
                &amp;i.StockQuantity,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getProducts = `-- name: GetProducts :many
SELECT id, name, description, price, category, stock_quantity, created_at, updated_at FROM products
`

func (q *Queries) GetProducts(ctx context.Context) ([]Product, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getProducts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Product{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Product
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Description,
                        &amp;i.Price,
                        &amp;i.Category,
                        &amp;i.StockQuantity,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getTenant = `-- name: GetTenant :one
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants WHERE id = $1
`

func (q *Queries) GetTenant(ctx context.Context, id uuid.UUID) (Tenant, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getTenant, id)
        var i Tenant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Domain,
                &amp;i.Settings,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getTenantBySlug = `-- name: GetTenantBySlug :one
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants WHERE slug = $1
`

func (q *Queries) GetTenantBySlug(ctx context.Context, slug string) (Tenant, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getTenantBySlug, slug)
        var i Tenant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Domain,
                &amp;i.Settings,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getTenants = `-- name: GetTenants :many
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants ORDER BY name
`

// Tenant Management Queries
func (q *Queries) GetTenants(ctx context.Context) ([]Tenant, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getTenants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Tenant{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Tenant
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Domain,
                        &amp;i.Settings,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, is_active, created_at, updated_at, tenant_id FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, first_name, last_name, is_active, created_at, updated_at, tenant_id FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getUserByID, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]Role, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []Role{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i Role
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Description,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getUserWithTenant = `-- name: GetUserWithTenant :one
SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name, u.is_active, u.created_at, u.updated_at, u.tenant_id, t.name as tenant_name, t.slug as tenant_slug 
FROM users u 
JOIN tenants t ON u.tenant_id = t.id 
WHERE u.id = $1
`

type GetUserWithTenantRow struct {
        ID           uuid.UUID      `json:"id"`
        Email        string         `json:"email"`
        PasswordHash string         `json:"password_hash"`
        FirstName    sql.NullString `json:"first_name"`
        LastName     sql.NullString `json:"last_name"`
        IsActive     sql.NullBool   `json:"is_active"`
        CreatedAt    sql.NullTime   `json:"created_at"`
        UpdatedAt    sql.NullTime   `json:"updated_at"`
        TenantID     uuid.NullUUID  `json:"tenant_id"`
        TenantName   string         `json:"tenant_name"`
        TenantSlug   string         `json:"tenant_slug"`
}

func (q *Queries) GetUserWithTenant(ctx context.Context, id uuid.UUID) (GetUserWithTenantRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getUserWithTenant, id)
        var i GetUserWithTenantRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
                &amp;i.TenantName,
                &amp;i.TenantSlug,
        )
        return i, err
}</span>

const getUsersByTenant = `-- name: GetUsersByTenant :many
SELECT id, email, password_hash, first_name, last_name, is_active, created_at, updated_at, tenant_id FROM users WHERE tenant_id = $1 ORDER BY email
`

// Enhanced User Queries with Tenant Support
func (q *Queries) GetUsersByTenant(ctx context.Context, tenantID uuid.NullUUID) ([]User, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getUsersByTenant, tenantID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        items := []User{}
        for rows.Next() </span><span class="cov0" title="0">{
                var i User
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Email,
                        &amp;i.PasswordHash,
                        &amp;i.FirstName,
                        &amp;i.LastName,
                        &amp;i.IsActive,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.TenantID,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateAPIKey = `-- name: UpdateAPIKey :one
UPDATE api_keys SET name = $2, is_active = $3, expires_at = $4, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at
`

type UpdateAPIKeyParams struct {
        ID        uuid.UUID    `json:"id"`
        Name      string       `json:"name"`
        IsActive  sql.NullBool `json:"is_active"`
        ExpiresAt sql.NullTime `json:"expires_at"`
}

func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) (ApiKey, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateAPIKey,
                arg.ID,
                arg.Name,
                arg.IsActive,
                arg.ExpiresAt,
        )
        var i ApiKey
        err := row.Scan(
                &amp;i.ID,
                &amp;i.UserID,
                &amp;i.Name,
                &amp;i.KeyHash,
                &amp;i.IsActive,
                &amp;i.ExpiresAt,
                &amp;i.LastUsedAt,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET last_used_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed, id)
        return err
}</span>

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections 
SET display_name = $2, description = $3, icon = $4, updated_at = CURRENT_TIMESTAMP, updated_by = $5
WHERE id = $1 RETURNING id, name, display_name, description, icon, is_system, created_at, updated_at, tenant_id, created_by, updated_by
`

type UpdateCollectionParams struct {
        ID          uuid.UUID      `json:"id"`
        DisplayName sql.NullString `json:"display_name"`
        Description sql.NullString `json:"description"`
        Icon        sql.NullString `json:"icon"`
        UpdatedBy   uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateCollection,
                arg.ID,
                arg.DisplayName,
                arg.Description,
                arg.Icon,
                arg.UpdatedBy,
        )
        var i Collection
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.IsSystem,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
                &amp;i.CreatedBy,
                &amp;i.UpdatedBy,
        )
        return i, err
}</span>

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE customers SET first_name = $2, last_name = $3, email = $4, phone = $5, address = $6, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, first_name, last_name, email, phone, address, created_at, updated_at
`

type UpdateCustomerParams struct {
        ID        uuid.UUID      `json:"id"`
        FirstName string         `json:"first_name"`
        LastName  string         `json:"last_name"`
        Email     string         `json:"email"`
        Phone     sql.NullString `json:"phone"`
        Address   sql.NullString `json:"address"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateCustomer,
                arg.ID,
                arg.FirstName,
                arg.LastName,
                arg.Email,
                arg.Phone,
                arg.Address,
        )
        var i Customer
        err := row.Scan(
                &amp;i.ID,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.Email,
                &amp;i.Phone,
                &amp;i.Address,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const updateField = `-- name: UpdateField :one
UPDATE fields 
SET display_name = $2, type = $3, is_primary = $4, is_required = $5, is_unique = $6, default_value = $7, validation_rules = $8, relation_config = $9, sort_order = $10, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 RETURNING id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at, tenant_id
`

type UpdateFieldParams struct {
        ID              uuid.UUID             `json:"id"`
        DisplayName     sql.NullString        `json:"display_name"`
        Type            string                `json:"type"`
        IsPrimary       sql.NullBool          `json:"is_primary"`
        IsRequired      sql.NullBool          `json:"is_required"`
        IsUnique        sql.NullBool          `json:"is_unique"`
        DefaultValue    sql.NullString        `json:"default_value"`
        ValidationRules pqtype.NullRawMessage `json:"validation_rules"`
        RelationConfig  pqtype.NullRawMessage `json:"relation_config"`
        SortOrder       sql.NullInt32         `json:"sort_order"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) (Field, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateField,
                arg.ID,
                arg.DisplayName,
                arg.Type,
                arg.IsPrimary,
                arg.IsRequired,
                arg.IsUnique,
                arg.DefaultValue,
                arg.ValidationRules,
                arg.RelationConfig,
                arg.SortOrder,
        )
        var i Field
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CollectionID,
                &amp;i.Name,
                &amp;i.DisplayName,
                &amp;i.Type,
                &amp;i.IsPrimary,
                &amp;i.IsRequired,
                &amp;i.IsUnique,
                &amp;i.DefaultValue,
                &amp;i.ValidationRules,
                &amp;i.RelationConfig,
                &amp;i.SortOrder,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders SET status = $2, notes = $3, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, customer_id, order_date, status, total_amount, notes, created_at, updated_at
`

type UpdateOrderParams struct {
        ID     uuid.UUID      `json:"id"`
        Status sql.NullString `json:"status"`
        Notes  sql.NullString `json:"notes"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateOrder, arg.ID, arg.Status, arg.Notes)
        var i Order
        err := row.Scan(
                &amp;i.ID,
                &amp;i.CustomerID,
                &amp;i.OrderDate,
                &amp;i.Status,
                &amp;i.TotalAmount,
                &amp;i.Notes,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE order_items SET order_id = $2, product_id = $3, quantity = $4, unit_price = $5 WHERE id = $1 RETURNING id, order_id, product_id, quantity, unit_price, created_at
`

type UpdateOrderItemParams struct {
        ID        uuid.UUID     `json:"id"`
        OrderID   uuid.NullUUID `json:"order_id"`
        ProductID uuid.NullUUID `json:"product_id"`
        Quantity  int32         `json:"quantity"`
        UnitPrice string        `json:"unit_price"`
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (OrderItem, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateOrderItem,
                arg.ID,
                arg.OrderID,
                arg.ProductID,
                arg.Quantity,
                arg.UnitPrice,
        )
        var i OrderItem
        err := row.Scan(
                &amp;i.ID,
                &amp;i.OrderID,
                &amp;i.ProductID,
                &amp;i.Quantity,
                &amp;i.UnitPrice,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions 
SET field_filter = $2, allowed_fields = $3, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 RETURNING id, role_id, table_name, action, field_filter, allowed_fields, created_at, updated_at, tenant_id
`

type UpdatePermissionParams struct {
        ID            uuid.UUID             `json:"id"`
        FieldFilter   pqtype.NullRawMessage `json:"field_filter"`
        AllowedFields []string              `json:"allowed_fields"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updatePermission, arg.ID, arg.FieldFilter, pq.Array(arg.AllowedFields))
        var i Permission
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RoleID,
                &amp;i.TableName,
                &amp;i.Action,
                &amp;i.FieldFilter,
                pq.Array(&amp;i.AllowedFields),
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>

const updateProduct = `-- name: UpdateProduct :one
UPDATE products SET name = $2, description = $3, price = $4, category = $5, stock_quantity = $6, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, name, description, price, category, stock_quantity, created_at, updated_at
`

type UpdateProductParams struct {
        ID            uuid.UUID      `json:"id"`
        Name          string         `json:"name"`
        Description   sql.NullString `json:"description"`
        Price         string         `json:"price"`
        Category      sql.NullString `json:"category"`
        StockQuantity sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateProduct,
                arg.ID,
                arg.Name,
                arg.Description,
                arg.Price,
                arg.Category,
                arg.StockQuantity,
        )
        var i Product
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Description,
                &amp;i.Price,
                &amp;i.Category,
                &amp;i.StockQuantity,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const updateTenant = `-- name: UpdateTenant :one
UPDATE tenants SET name = $2, slug = $3, domain = $4, settings = $5, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, name, slug, domain, settings, is_active, created_at, updated_at
`

type UpdateTenantParams struct {
        ID       uuid.UUID             `json:"id"`
        Name     string                `json:"name"`
        Slug     string                `json:"slug"`
        Domain   sql.NullString        `json:"domain"`
        Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (Tenant, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateTenant,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Domain,
                arg.Settings,
        )
        var i Tenant
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Domain,
                &amp;i.Settings,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET email = $2, first_name = $3, last_name = $4, is_active = $5, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 RETURNING id, email, password_hash, first_name, last_name, is_active, created_at, updated_at, tenant_id
`

type UpdateUserParams struct {
        ID        uuid.UUID      `json:"id"`
        Email     string         `json:"email"`
        FirstName sql.NullString `json:"first_name"`
        LastName  sql.NullString `json:"last_name"`
        IsActive  sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateUser,
                arg.ID,
                arg.Email,
                arg.FirstName,
                arg.LastName,
                arg.IsActive,
        )
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.FirstName,
                &amp;i.LastName,
                &amp;i.IsActive,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.TenantID,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "crypto/sha256"
        "encoding/hex"
        "net/http"
        "strings"
        "time"

        "go-rbac-api/internal/config"
        "go-rbac-api/internal/db"
        "go-rbac-api/internal/models"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
)

type Claims struct {
        UserID uuid.UUID `json:"user_id"`
        Email  string    `json:"email"`
        jwt.RegisteredClaims
}

func GenerateToken(user models.User, cfg *config.Config) (string, error) <span class="cov0" title="0">{
        expirationTime := time.Now().Add(cfg.JWTExpiry)

        claims := &amp;Claims{
                UserID: user.ID,
                Email:  user.Email,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(cfg.JWTSecret))
}</span>

func AuthMiddleware(cfg *config.Config, db *db.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
                        c.Abort()
                        return
                }</span>

                // Check if the header starts with "Bearer "
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
                        c.Abort()
                        return
                }</span>

                // Extract the token
                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")

                // First, try to validate as JWT token
                token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(cfg.JWTSecret), nil
                }</span>)

                <span class="cov0" title="0">if err == nil &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                        if claims, ok := token.Claims.(*Claims); ok </span><span class="cov0" title="0">{
                                // Store user information in context
                                c.Set("user_id", claims.UserID)
                                c.Set("email", claims.Email)
                                c.Set("auth_type", "jwt")
                                c.Next()
                                return
                        }</span>
                }

                // If JWT validation failed, try API key authentication
                // Hash the API key to match what's stored in the database
                <span class="cov0" title="0">keyHash := hashAPIKey(tokenString)
                apiKey, err := db.Queries.GetAPIKeyByHash(c.Request.Context(), keyHash)
                if err == nil &amp;&amp; apiKey.IsActive.Bool </span><span class="cov0" title="0">{
                        // Check if API key is expired
                        if apiKey.ExpiresAt.Valid &amp;&amp; apiKey.ExpiresAt.Time.Before(time.Now()) </span><span class="cov0" title="0">{
                                c.JSON(http.StatusUnauthorized, gin.H{"error": "API key expired"})
                                c.Abort()
                                return
                        }</span>

                        // Update last used timestamp
                        <span class="cov0" title="0">db.Queries.UpdateAPIKeyLastUsed(c.Request.Context(), apiKey.ID)

                        // Get user information
                        user, err := db.Queries.GetUserByID(c.Request.Context(), apiKey.UserID)
                        if err == nil </span><span class="cov0" title="0">{
                                c.Set("user_id", user.ID)
                                c.Set("email", user.Email)
                                c.Set("auth_type", "api_key")
                                c.Next()
                                return
                        }</span>
                }

                // If both JWT and API key authentication failed
                <span class="cov0" title="0">c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token or API key"})
                c.Abort()</span>
        }
}

func GetUserID(c *gin.Context) (uuid.UUID, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return uuid.Nil, false
        }</span>

        <span class="cov0" title="0">if id, ok := userID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                return id, true
        }</span>

        <span class="cov0" title="0">return uuid.Nil, false</span>
}

func GetEmail(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        email, exists := c.Get("email")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        <span class="cov0" title="0">if e, ok := email.(string); ok </span><span class="cov0" title="0">{
                return e, true
        }</span>

        <span class="cov0" title="0">return "", false</span>
}

// hashAPIKey creates a SHA-256 hash of the API key for secure storage
func hashAPIKey(apiKey string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(apiKey))
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package models

import (
        "time"

        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

type User struct {
        ID           uuid.UUID `json:"id"`
        Email        string    `json:"email"`
        PasswordHash string    `json:"-"` // Never expose password hash in JSON
        FirstName    string    `json:"first_name"`
        LastName     string    `json:"last_name"`
        IsActive     bool      `json:"is_active"`
        CreatedAt    time.Time `json:"created_at"`
        UpdatedAt    time.Time `json:"updated_at"`
}

type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required"`
}

type LoginResponse struct {
        Token string `json:"token"`
        User  User   `json:"user"`
}

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

func CheckPassword(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span> </pre>
		
		<pre class="file" id="file9" style="display: none">package rbac

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        sqlc "go-rbac-api/internal/db/sqlc"

        "github.com/google/uuid"
)

type PolicyChecker struct {
        db *sqlc.Queries
}

func NewPolicyChecker(db *sqlc.Queries) *PolicyChecker <span class="cov0" title="0">{
        return &amp;PolicyChecker{db: db}
}</span>

// CheckPermission checks if a user has permission to perform an action on a table
func (pc *PolicyChecker) CheckPermission(ctx context.Context, userID uuid.UUID, tableName, action string) (bool, []string, error) <span class="cov0" title="0">{
        // Get user roles
        roles, err := pc.db.GetUserRoles(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get user roles: %w", err)
        }</span>

        // Get user's tenant ID
        <span class="cov0" title="0">user, err := pc.db.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // Check permissions for each role with tenant isolation
        <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                // Check permissions for this role and tenant
                permissions, err := pc.db.GetPermissionsByRoleAndTenant(ctx, sqlc.GetPermissionsByRoleAndTenantParams{
                        RoleID:   uuid.NullUUID{UUID: role.ID, Valid: true},
                        TenantID: user.TenantID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip this role if there's an error
                }

                <span class="cov0" title="0">for _, permission := range permissions </span><span class="cov0" title="0">{
                        // Check if permission matches table and action
                        if permission.TableName == tableName &amp;&amp; permission.Action == action </span><span class="cov0" title="0">{
                                allowedFields := permission.AllowedFields
                                if len(allowedFields) == 0 </span><span class="cov0" title="0">{
                                        allowedFields = []string{"*"} // Default to all fields
                                }</span>
                                <span class="cov0" title="0">return true, allowedFields, nil</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, nil, nil</span>
}

// CheckPermissionWithTenant checks if a user has permission with explicit tenant context
func (pc *PolicyChecker) CheckPermissionWithTenant(ctx context.Context, userID, tenantID uuid.UUID, tableName, action string) (bool, []string, error) <span class="cov0" title="0">{
        // Get user roles
        roles, err := pc.db.GetUserRoles(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("failed to get user roles: %w", err)
        }</span>

        // Check permissions for each role with specific tenant
        <span class="cov0" title="0">for _, role := range roles </span><span class="cov0" title="0">{
                permissions, err := pc.db.GetPermissionsByRoleAndTenant(ctx, sqlc.GetPermissionsByRoleAndTenantParams{
                        RoleID:   uuid.NullUUID{UUID: role.ID, Valid: true},
                        TenantID: uuid.NullUUID{UUID: tenantID, Valid: true},
                })
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip this role if there's an error
                }

                <span class="cov0" title="0">for _, permission := range permissions </span><span class="cov0" title="0">{
                        // Check if permission matches table and action
                        if permission.TableName == tableName &amp;&amp; permission.Action == action </span><span class="cov0" title="0">{
                                allowedFields := permission.AllowedFields
                                if len(allowedFields) == 0 </span><span class="cov0" title="0">{
                                        allowedFields = []string{"*"} // Default to all fields
                                }</span>
                                <span class="cov0" title="0">return true, allowedFields, nil</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, nil, nil</span>
}

// FilterFields filters the data based on allowed fields for the user
func (pc *PolicyChecker) FilterFields(data map[string]interface{}, allowedFields []string) map[string]interface{} <span class="cov0" title="0">{
        if len(allowedFields) == 0 </span><span class="cov0" title="0">{
                return data
        }</span>

        // Check if all fields are allowed
        <span class="cov0" title="0">for _, field := range allowedFields </span><span class="cov0" title="0">{
                if field == "*" </span><span class="cov0" title="0">{
                        return data // All fields allowed
                }</span>
        }

        // Filter to only allowed fields
        <span class="cov0" title="0">filtered := make(map[string]interface{})
        for _, field := range allowedFields </span><span class="cov0" title="0">{
                if value, exists := data[field]; exists </span><span class="cov0" title="0">{
                        filtered[field] = value
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

// FilterRecords applies row-level filtering based on field filters
func (pc *PolicyChecker) FilterRecords(records []map[string]interface{}, fieldFilter json.RawMessage) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        if fieldFilter == nil </span><span class="cov0" title="0">{
                return records, nil
        }</span>

        <span class="cov0" title="0">var filter map[string]interface{}
        if err := json.Unmarshal(fieldFilter, &amp;filter); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal field filter: %w", err)
        }</span>

        <span class="cov0" title="0">var filtered []map[string]interface{}
        for _, record := range records </span><span class="cov0" title="0">{
                match := true
                for key, value := range filter </span><span class="cov0" title="0">{
                        if recordValue, exists := record[key]; !exists || recordValue != value </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                        filtered = append(filtered, record)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// ConvertToMap converts a struct to a map for filtering
func ConvertToMap(data interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        err = json.Unmarshal(jsonData, &amp;result)
        return result, err</span>
}

// ConvertFromMap converts a map back to JSON bytes
func ConvertFromMap(data map[string]interface{}) ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(data)
}</span>

// ValidateTableName ensures the table name is safe
func ValidateTableName(tableName string) bool <span class="cov0" title="0">{
        // Simple validation - only allow alphanumeric and underscores
        for _, char := range tableName </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '_') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// BuildSelectQuery builds a safe SELECT query with field filtering
func BuildSelectQuery(tableName string, allowedFields []string) string <span class="cov0" title="0">{
        if len(allowedFields) == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("SELECT * FROM %s", tableName)
        }</span>

        // Check if all fields are allowed
        <span class="cov0" title="0">for _, field := range allowedFields </span><span class="cov0" title="0">{
                if field == "*" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("SELECT * FROM %s", tableName)
                }</span>
        }

        // Build field list
        <span class="cov0" title="0">fields := make([]string, len(allowedFields))
        for i, field := range allowedFields </span><span class="cov0" title="0">{
                fields[i] = fmt.Sprintf(`"%s"`, field)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("SELECT %s FROM %s", strings.Join(fields, ", "), tableName)</span>
}

// BuildSelectQueryWithTenant builds a safe SELECT query with tenant schema
func BuildSelectQueryWithTenant(tenantSchema, tableName string, allowedFields []string) string <span class="cov0" title="0">{
        fullTableName := fmt.Sprintf("%s.data_%s", tenantSchema, tableName)

        if len(allowedFields) == 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("SELECT * FROM %s", fullTableName)
        }</span>

        // Check if all fields are allowed
        <span class="cov0" title="0">for _, field := range allowedFields </span><span class="cov0" title="0">{
                if field == "*" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("SELECT * FROM %s", fullTableName)
                }</span>
        }

        // Build field list
        <span class="cov0" title="0">fields := make([]string, len(allowedFields))
        for i, field := range allowedFields </span><span class="cov0" title="0">{
                fields[i] = fmt.Sprintf(`"%s"`, field)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("SELECT %s FROM %s", strings.Join(fields, ", "), fullTableName)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package schema

import (
        "context"
        "database/sql"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
)

type SchemaManager struct {
        db *sql.DB
}

type Collection struct {
        ID          uuid.UUID `json:"id"`
        Name        string    `json:"name"`
        DisplayName string    `json:"display_name"`
        Description string    `json:"description"`
        Icon        string    `json:"icon"`
        IsSystem    bool      `json:"is_system"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
        Fields      []Field   `json:"fields,omitempty"`
}

type Field struct {
        ID              uuid.UUID              `json:"id"`
        CollectionID    uuid.UUID              `json:"collection_id"`
        Name            string                 `json:"name"`
        DisplayName     string                 `json:"display_name"`
        Type            string                 `json:"type"`
        IsPrimary       bool                   `json:"is_primary"`
        IsRequired      bool                   `json:"is_required"`
        IsUnique        bool                   `json:"is_unique"`
        DefaultValue    string                 `json:"default_value"`
        ValidationRules map[string]interface{} `json:"validation_rules"`
        RelationConfig  map[string]interface{} `json:"relation_config"`
        SortOrder       int                    `json:"sort_order"`
        CreatedAt       time.Time              `json:"created_at"`
        UpdatedAt       time.Time              `json:"updated_at"`
}

func NewSchemaManager(db *sql.DB) *SchemaManager <span class="cov0" title="0">{
        return &amp;SchemaManager{db: db}
}</span>

// CreateCollection creates a new collection and its corresponding data table
func (sm *SchemaManager) CreateCollection(ctx context.Context, collection Collection) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := sm.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Insert collection record
        collectionQuery := `
                INSERT INTO collections (id, name, display_name, description, icon, is_system)
                VALUES ($1, $2, $3, $4, $5, $6)
        `
        _, err = tx.ExecContext(ctx, collectionQuery,
                collection.ID, collection.Name, collection.DisplayName,
                collection.Description, collection.Icon, collection.IsSystem)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert collection: %w", err)
        }</span>

        // Create corresponding data table
        <span class="cov0" title="0">dataTableName := "data_" + collection.Name
        createTableQuery := sm.buildCreateTableQuery(dataTableName, collection.Fields)

        _, err = tx.ExecContext(ctx, createTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create data table: %w", err)
        }</span>

        // Insert fields
        <span class="cov0" title="0">for _, field := range collection.Fields </span><span class="cov0" title="0">{
                fieldQuery := `
                        INSERT INTO fields (id, collection_id, name, display_name, type, is_primary, 
                                is_required, is_unique, default_value, validation_rules, relation_config, sort_order)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
                `
                _, err = tx.ExecContext(ctx, fieldQuery,
                        field.ID, collection.ID, field.Name, field.DisplayName, field.Type,
                        field.IsPrimary, field.IsRequired, field.IsUnique, field.DefaultValue,
                        field.ValidationRules, field.RelationConfig, field.SortOrder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to insert field: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// UpdateCollection updates a collection and its data table schema
func (sm *SchemaManager) UpdateCollection(ctx context.Context, collection Collection) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := sm.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Update collection record
        collectionQuery := `
                UPDATE collections 
                SET display_name = $2, description = $3, icon = $4, updated_at = NOW()
                WHERE id = $1
        `
        _, err = tx.ExecContext(ctx, collectionQuery,
                collection.ID, collection.DisplayName, collection.Description, collection.Icon)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update collection: %w", err)
        }</span>

        // Handle field updates (simplified - in production you'd need more sophisticated schema migration)
        // For now, we'll just update the field records
        <span class="cov0" title="0">for _, field := range collection.Fields </span><span class="cov0" title="0">{
                fieldQuery := `
                        UPDATE fields 
                        SET display_name = $3, type = $4, is_primary = $5, is_required = $6, 
                                is_unique = $7, default_value = $8, validation_rules = $9, 
                                relation_config = $10, sort_order = $11, updated_at = NOW()
                        WHERE id = $1 AND collection_id = $2
                `
                _, err = tx.ExecContext(ctx, fieldQuery,
                        field.ID, collection.ID, field.DisplayName, field.Type,
                        field.IsPrimary, field.IsRequired, field.IsUnique, field.DefaultValue,
                        field.ValidationRules, field.RelationConfig, field.SortOrder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update field: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// DeleteCollection deletes a collection and its data table
func (sm *SchemaManager) DeleteCollection(ctx context.Context, collectionID uuid.UUID) error <span class="cov0" title="0">{
        // Start transaction
        tx, err := sm.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Get collection name
        var collectionName string
        err = tx.QueryRowContext(ctx, "SELECT name FROM collections WHERE id = $1", collectionID).Scan(&amp;collectionName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection name: %w", err)
        }</span>

        // Drop data table
        <span class="cov0" title="0">dataTableName := "data_" + collectionName
        dropTableQuery := fmt.Sprintf("DROP TABLE IF EXISTS %s CASCADE", dataTableName)
        _, err = tx.ExecContext(ctx, dropTableQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop data table: %w", err)
        }</span>

        // Delete collection (fields will be deleted via CASCADE)
        <span class="cov0" title="0">_, err = tx.ExecContext(ctx, "DELETE FROM collections WHERE id = $1", collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete collection: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetCollection retrieves a collection with its fields
func (sm *SchemaManager) GetCollection(ctx context.Context, collectionID uuid.UUID) (*Collection, error) <span class="cov0" title="0">{
        // Get collection
        var collection Collection
        collectionQuery := `
                SELECT id, name, display_name, description, icon, is_system, created_at, updated_at
                FROM collections WHERE id = $1
        `
        err := sm.db.QueryRowContext(ctx, collectionQuery, collectionID).Scan(
                &amp;collection.ID, &amp;collection.Name, &amp;collection.DisplayName, &amp;collection.Description,
                &amp;collection.Icon, &amp;collection.IsSystem, &amp;collection.CreatedAt, &amp;collection.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get collection: %w", err)
        }</span>

        // Get fields
        <span class="cov0" title="0">fieldsQuery := `
                SELECT id, collection_id, name, display_name, type, is_primary, is_required, 
                        is_unique, default_value, validation_rules, relation_config, sort_order, created_at, updated_at
                FROM fields WHERE collection_id = $1 ORDER BY sort_order
        `
        rows, err := sm.db.QueryContext(ctx, fieldsQuery, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get fields: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var field Field
                err := rows.Scan(
                        &amp;field.ID, &amp;field.CollectionID, &amp;field.Name, &amp;field.DisplayName, &amp;field.Type,
                        &amp;field.IsPrimary, &amp;field.IsRequired, &amp;field.IsUnique, &amp;field.DefaultValue,
                        &amp;field.ValidationRules, &amp;field.RelationConfig, &amp;field.SortOrder,
                        &amp;field.CreatedAt, &amp;field.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan field: %w", err)
                }</span>
                <span class="cov0" title="0">collection.Fields = append(collection.Fields, field)</span>
        }

        <span class="cov0" title="0">return &amp;collection, nil</span>
}

// ListCollections retrieves all collections
func (sm *SchemaManager) ListCollections(ctx context.Context) ([]Collection, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, display_name, description, icon, is_system, created_at, updated_at
                FROM collections ORDER BY name
        `
        rows, err := sm.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list collections: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var collections []Collection
        for rows.Next() </span><span class="cov0" title="0">{
                var collection Collection
                err := rows.Scan(
                        &amp;collection.ID, &amp;collection.Name, &amp;collection.DisplayName, &amp;collection.Description,
                        &amp;collection.Icon, &amp;collection.IsSystem, &amp;collection.CreatedAt, &amp;collection.UpdatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan collection: %w", err)
                }</span>
                <span class="cov0" title="0">collections = append(collections, collection)</span>
        }

        <span class="cov0" title="0">return collections, nil</span>
}

// buildCreateTableQuery builds the SQL to create a data table based on fields
func (sm *SchemaManager) buildCreateTableQuery(tableName string, fields []Field) string <span class="cov0" title="0">{
        var columns []string

        // Always add standard columns
        columns = append(columns, "id UUID PRIMARY KEY DEFAULT uuid_generate_v4()")
        columns = append(columns, "created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()")
        columns = append(columns, "updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()")

        // Add field columns
        for _, field := range fields </span><span class="cov0" title="0">{
                columnDef := sm.buildColumnDefinition(field)
                columns = append(columns, columnDef)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("CREATE TABLE %s (\n  %s\n)", tableName, strings.Join(columns, ",\n  "))
        return query</span>
}

// buildColumnDefinition builds the SQL definition for a field
func (sm *SchemaManager) buildColumnDefinition(field Field) string <span class="cov0" title="0">{
        var parts []string

        // Column name
        parts = append(parts, fmt.Sprintf(`"%s"`, field.Name))

        // Data type
        switch field.Type </span>{
        case "string":<span class="cov0" title="0">
                parts = append(parts, "VARCHAR(255)")</span>
        case "text":<span class="cov0" title="0">
                parts = append(parts, "TEXT")</span>
        case "integer":<span class="cov0" title="0">
                parts = append(parts, "INTEGER")</span>
        case "decimal":<span class="cov0" title="0">
                parts = append(parts, "DECIMAL(10,2)")</span>
        case "boolean":<span class="cov0" title="0">
                parts = append(parts, "BOOLEAN")</span>
        case "datetime":<span class="cov0" title="0">
                parts = append(parts, "TIMESTAMP WITH TIME ZONE")</span>
        case "json":<span class="cov0" title="0">
                parts = append(parts, "JSONB")</span>
        case "uuid":<span class="cov0" title="0">
                parts = append(parts, "UUID")</span>
        case "relation":<span class="cov0" title="0">
                // Handle relation fields - would need to reference the related table
                if relConfig, ok := field.RelationConfig["related_collection"].(string); ok </span><span class="cov0" title="0">{
                        parts = append(parts, fmt.Sprintf("UUID REFERENCES data_%s(id)", relConfig))
                }</span> else<span class="cov0" title="0"> {
                        parts = append(parts, "UUID")
                }</span>
        default:<span class="cov0" title="0">
                parts = append(parts, "TEXT")</span>
        }

        // Constraints
        <span class="cov0" title="0">if field.IsRequired </span><span class="cov0" title="0">{
                parts = append(parts, "NOT NULL")
        }</span>

        <span class="cov0" title="0">if field.IsUnique </span><span class="cov0" title="0">{
                parts = append(parts, "UNIQUE")
        }</span>

        <span class="cov0" title="0">if field.DefaultValue != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("DEFAULT %s", field.DefaultValue))
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "fmt"
        "os"

        "golang.org/x/crypto/bcrypt"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) != 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: go run hash_password.go &lt;password&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">password := os.Args[1]
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error hashing password: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println(string(hash))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
