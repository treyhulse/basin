// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const addUserRole = `-- name: AddUserRole :exec
INSERT INTO user_roles (user_id, role_id) VALUES ($1, $2) ON CONFLICT (user_id, role_id) DO NOTHING
`

type AddUserRoleParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoleID uuid.UUID `json:"role_id"`
}

func (q *Queries) AddUserRole(ctx context.Context, arg AddUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, addUserRole, arg.UserID, arg.RoleID)
	return err
}

const addUserToTenant = `-- name: AddUserToTenant :exec
INSERT INTO user_tenants (user_id, tenant_id, role_id, is_active) VALUES ($1, $2, $3, true)
`

type AddUserToTenantParams struct {
	UserID   uuid.UUID     `json:"user_id"`
	TenantID uuid.UUID     `json:"tenant_id"`
	RoleID   uuid.NullUUID `json:"role_id"`
}

func (q *Queries) AddUserToTenant(ctx context.Context, arg AddUserToTenantParams) error {
	_, err := q.db.ExecContext(ctx, addUserToTenant, arg.UserID, arg.TenantID, arg.RoleID)
	return err
}

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (user_id, name, key_hash, expires_at) VALUES ($1, $2, $3, $4) RETURNING id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at
`

type CreateAPIKeyParams struct {
	UserID    uuid.UUID    `json:"user_id"`
	Name      string       `json:"name"`
	KeyHash   string       `json:"key_hash"`
	ExpiresAt sql.NullTime `json:"expires_at"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, createAPIKey,
		arg.UserID,
		arg.Name,
		arg.KeyHash,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (id, name, display_name, description, icon, is_system, tenant_id, created_by) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, name, display_name, description, icon, is_system, tenant_id, created_by, updated_by, created_at, updated_at
`

type CreateCollectionParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	DisplayName sql.NullString `json:"display_name"`
	Description sql.NullString `json:"description"`
	Icon        sql.NullString `json:"icon"`
	IsSystem    sql.NullBool   `json:"is_system"`
	TenantID    uuid.NullUUID  `json:"tenant_id"`
	CreatedBy   uuid.NullUUID  `json:"created_by"`
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, createCollection,
		arg.ID,
		arg.Name,
		arg.DisplayName,
		arg.Description,
		arg.Icon,
		arg.IsSystem,
		arg.TenantID,
		arg.CreatedBy,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Icon,
		&i.IsSystem,
		&i.TenantID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createField = `-- name: CreateField :one
INSERT INTO fields (id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, relation_config, sort_order, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, sort_order, relation_config, tenant_id, created_at, updated_at
`

type CreateFieldParams struct {
	ID              uuid.UUID             `json:"id"`
	CollectionID    uuid.NullUUID         `json:"collection_id"`
	Name            string                `json:"name"`
	DisplayName     sql.NullString        `json:"display_name"`
	Type            string                `json:"type"`
	IsPrimary       sql.NullBool          `json:"is_primary"`
	IsRequired      sql.NullBool          `json:"is_required"`
	IsUnique        sql.NullBool          `json:"is_unique"`
	DefaultValue    sql.NullString        `json:"default_value"`
	ValidationRules pqtype.NullRawMessage `json:"validation_rules"`
	RelationConfig  pqtype.NullRawMessage `json:"relation_config"`
	SortOrder       sql.NullInt32         `json:"sort_order"`
	TenantID        uuid.NullUUID         `json:"tenant_id"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) (Field, error) {
	row := q.db.QueryRowContext(ctx, createField,
		arg.ID,
		arg.CollectionID,
		arg.Name,
		arg.DisplayName,
		arg.Type,
		arg.IsPrimary,
		arg.IsRequired,
		arg.IsUnique,
		arg.DefaultValue,
		arg.ValidationRules,
		arg.RelationConfig,
		arg.SortOrder,
		arg.TenantID,
	)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.IsPrimary,
		&i.IsRequired,
		&i.IsUnique,
		&i.DefaultValue,
		&i.ValidationRules,
		&i.SortOrder,
		&i.RelationConfig,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (id, role_id, table_name, action, field_filter, allowed_fields, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at
`

type CreatePermissionParams struct {
	ID            uuid.UUID             `json:"id"`
	RoleID        uuid.NullUUID         `json:"role_id"`
	TableName     string                `json:"table_name"`
	Action        string                `json:"action"`
	FieldFilter   pqtype.NullRawMessage `json:"field_filter"`
	AllowedFields []string              `json:"allowed_fields"`
	TenantID      uuid.NullUUID         `json:"tenant_id"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, createPermission,
		arg.ID,
		arg.RoleID,
		arg.TableName,
		arg.Action,
		arg.FieldFilter,
		pq.Array(arg.AllowedFields),
		arg.TenantID,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.TableName,
		&i.Action,
		&i.FieldFilter,
		pq.Array(&i.AllowedFields),
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (id, name, description, tenant_id) 
VALUES ($1, $2, $3, $4) RETURNING id, name, description, tenant_id, created_at, updated_at
`

type CreateRoleParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	TenantID    uuid.NullUUID  `json:"tenant_id"`
}

// Role Management Queries
func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.TenantID,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (id, name, slug, domain, settings) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, slug, domain, settings, is_active, created_at, updated_at
`

type CreateTenantParams struct {
	ID       uuid.UUID             `json:"id"`
	Name     string                `json:"name"`
	Slug     string                `json:"slug"`
	Domain   sql.NullString        `json:"domain"`
	Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, createTenant,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Domain,
		arg.Settings,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, password_hash, first_name, last_name, tenant_id) 
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, email, password_hash, first_name, last_name, is_active, tenant_id, created_at, updated_at
`

type CreateUserParams struct {
	ID           uuid.UUID      `json:"id"`
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	TenantID     uuid.NullUUID  `json:"tenant_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.TenantID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE id = $1
`

func (q *Queries) DeleteAPIKey(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAPIKey, id)
	return err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCollection, id)
	return err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields WHERE id = $1
`

func (q *Queries) DeleteField(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteField, id)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePermission, id)
	return err
}

const deleteTenant = `-- name: DeleteTenant :exec
DELETE FROM tenants WHERE id = $1
`

func (q *Queries) DeleteTenant(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTenant, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAPIKeyByHash = `-- name: GetAPIKeyByHash :one

SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE key_hash = $1 AND is_active = true
`

// Note: Customer queries removedm - customers are now managed through dynamic collections
// The data_customers table is created automatically when the customers collection is created
// API Key Management Queries
func (q *Queries) GetAPIKeyByHash(ctx context.Context, keyHash string) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByHash, keyHash)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIKeyByID = `-- name: GetAPIKeyByID :one
SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE id = $1
`

func (q *Queries) GetAPIKeyByID(ctx context.Context, id uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, getAPIKeyByID, id)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAPIKeysByUser = `-- name: GetAPIKeysByUser :many
SELECT id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetAPIKeysByUser(ctx context.Context, userID uuid.UUID) ([]ApiKey, error) {
	rows, err := q.db.QueryContext(ctx, getAPIKeysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ApiKey{}
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.KeyHash,
			&i.IsActive,
			&i.ExpiresAt,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTenants = `-- name: GetAllTenants :many
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants ORDER BY created_at
`

// User-Tenant Relationship Queries
func (q *Queries) GetAllTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.QueryContext(ctx, getAllTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Domain,
			&i.Settings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollection = `-- name: GetCollection :one
SELECT id, name, display_name, description, icon, is_system, tenant_id, created_by, updated_by, created_at, updated_at FROM collections WHERE id = $1
`

func (q *Queries) GetCollection(ctx context.Context, id uuid.UUID) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollection, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Icon,
		&i.IsSystem,
		&i.TenantID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionByNameAndTenant = `-- name: GetCollectionByNameAndTenant :one
SELECT id, name, display_name, description, icon, is_system, tenant_id, created_by, updated_by, created_at, updated_at FROM collections WHERE name = $1 AND tenant_id = $2
`

type GetCollectionByNameAndTenantParams struct {
	Name     string        `json:"name"`
	TenantID uuid.NullUUID `json:"tenant_id"`
}

func (q *Queries) GetCollectionByNameAndTenant(ctx context.Context, arg GetCollectionByNameAndTenantParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, getCollectionByNameAndTenant, arg.Name, arg.TenantID)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Icon,
		&i.IsSystem,
		&i.TenantID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollections = `-- name: GetCollections :many
SELECT id, name, display_name, description, icon, is_system, tenant_id, created_by, updated_by, created_at, updated_at FROM collections ORDER BY name
`

// Schema Management Queries
func (q *Queries) GetCollections(ctx context.Context) ([]Collection, error) {
	rows, err := q.db.QueryContext(ctx, getCollections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Collection{}
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
			&i.Icon,
			&i.IsSystem,
			&i.TenantID,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getField = `-- name: GetField :one
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, sort_order, relation_config, tenant_id, created_at, updated_at FROM fields WHERE id = $1
`

func (q *Queries) GetField(ctx context.Context, id uuid.UUID) (Field, error) {
	row := q.db.QueryRowContext(ctx, getField, id)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.IsPrimary,
		&i.IsRequired,
		&i.IsUnique,
		&i.DefaultValue,
		&i.ValidationRules,
		&i.SortOrder,
		&i.RelationConfig,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFields = `-- name: GetFields :many
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, sort_order, relation_config, tenant_id, created_at, updated_at FROM fields ORDER BY sort_order
`

func (q *Queries) GetFields(ctx context.Context) ([]Field, error) {
	rows, err := q.db.QueryContext(ctx, getFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Field{}
	for rows.Next() {
		var i Field
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Name,
			&i.DisplayName,
			&i.Type,
			&i.IsPrimary,
			&i.IsRequired,
			&i.IsUnique,
			&i.DefaultValue,
			&i.ValidationRules,
			&i.SortOrder,
			&i.RelationConfig,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFieldsByCollection = `-- name: GetFieldsByCollection :many
SELECT id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, sort_order, relation_config, tenant_id, created_at, updated_at FROM fields WHERE collection_id = $1 ORDER BY sort_order
`

func (q *Queries) GetFieldsByCollection(ctx context.Context, collectionID uuid.NullUUID) ([]Field, error) {
	rows, err := q.db.QueryContext(ctx, getFieldsByCollection, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Field{}
	for rows.Next() {
		var i Field
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Name,
			&i.DisplayName,
			&i.Type,
			&i.IsPrimary,
			&i.IsRequired,
			&i.IsUnique,
			&i.DefaultValue,
			&i.ValidationRules,
			&i.SortOrder,
			&i.RelationConfig,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByRole = `-- name: GetPermissionsByRole :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at FROM permissions WHERE role_id = $1
`

func (q *Queries) GetPermissionsByRole(ctx context.Context, roleID uuid.NullUUID) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.TableName,
			&i.Action,
			&i.FieldFilter,
			pq.Array(&i.AllowedFields),
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByRoleAndAction = `-- name: GetPermissionsByRoleAndAction :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at FROM permissions WHERE role_id = $1 AND table_name = $2 AND action = $3
`

type GetPermissionsByRoleAndActionParams struct {
	RoleID    uuid.NullUUID `json:"role_id"`
	TableName string        `json:"table_name"`
	Action    string        `json:"action"`
}

func (q *Queries) GetPermissionsByRoleAndAction(ctx context.Context, arg GetPermissionsByRoleAndActionParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndAction, arg.RoleID, arg.TableName, arg.Action)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.TableName,
			&i.Action,
			&i.FieldFilter,
			pq.Array(&i.AllowedFields),
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByRoleAndTable = `-- name: GetPermissionsByRoleAndTable :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at FROM permissions WHERE role_id = $1 AND table_name = $2
`

type GetPermissionsByRoleAndTableParams struct {
	RoleID    uuid.NullUUID `json:"role_id"`
	TableName string        `json:"table_name"`
}

func (q *Queries) GetPermissionsByRoleAndTable(ctx context.Context, arg GetPermissionsByRoleAndTableParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndTable, arg.RoleID, arg.TableName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.TableName,
			&i.Action,
			&i.FieldFilter,
			pq.Array(&i.AllowedFields),
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByRoleAndTenant = `-- name: GetPermissionsByRoleAndTenant :many
SELECT id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at FROM permissions WHERE role_id = $1 AND tenant_id = $2
`

type GetPermissionsByRoleAndTenantParams struct {
	RoleID   uuid.NullUUID `json:"role_id"`
	TenantID uuid.NullUUID `json:"tenant_id"`
}

// Enhanced Permission Queries with Tenant Support
func (q *Queries) GetPermissionsByRoleAndTenant(ctx context.Context, arg GetPermissionsByRoleAndTenantParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByRoleAndTenant, arg.RoleID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.TableName,
			&i.Action,
			&i.FieldFilter,
			pq.Array(&i.AllowedFields),
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByUserAndTenant = `-- name: GetPermissionsByUserAndTenant :many
SELECT p.id, p.role_id, p.table_name, p.action, p.field_filter, p.allowed_fields, p.tenant_id, p.created_at, p.updated_at FROM permissions p
JOIN user_roles ur ON p.role_id = ur.role_id
WHERE ur.user_id = $1 AND p.tenant_id = $2
`

type GetPermissionsByUserAndTenantParams struct {
	UserID   uuid.UUID     `json:"user_id"`
	TenantID uuid.NullUUID `json:"tenant_id"`
}

func (q *Queries) GetPermissionsByUserAndTenant(ctx context.Context, arg GetPermissionsByUserAndTenantParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserAndTenant, arg.UserID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.TableName,
			&i.Action,
			&i.FieldFilter,
			pq.Array(&i.AllowedFields),
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByNameAndTenant = `-- name: GetRoleByNameAndTenant :one
SELECT id, name, description, tenant_id, created_at, updated_at FROM roles WHERE name = $1 AND tenant_id = $2
`

type GetRoleByNameAndTenantParams struct {
	Name     string        `json:"name"`
	TenantID uuid.NullUUID `json:"tenant_id"`
}

func (q *Queries) GetRoleByNameAndTenant(ctx context.Context, arg GetRoleByNameAndTenantParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByNameAndTenant, arg.Name, arg.TenantID)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRolesByTenant = `-- name: GetRolesByTenant :many
SELECT id, name, description, tenant_id, created_at, updated_at FROM roles WHERE tenant_id = $1 ORDER BY name
`

func (q *Queries) GetRolesByTenant(ctx context.Context, tenantID uuid.NullUUID) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getRolesByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenant = `-- name: GetTenant :one
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants WHERE id = $1
`

func (q *Queries) GetTenant(ctx context.Context, id uuid.UUID) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getTenant, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants WHERE id = $1
`

func (q *Queries) GetTenantByID(ctx context.Context, id uuid.UUID) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantBySlug = `-- name: GetTenantBySlug :one
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants WHERE slug = $1
`

func (q *Queries) GetTenantBySlug(ctx context.Context, slug string) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getTenantBySlug, slug)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenants = `-- name: GetTenants :many
SELECT id, name, slug, domain, settings, is_active, created_at, updated_at FROM tenants ORDER BY name
`

// Tenant Management Queries
func (q *Queries) GetTenants(ctx context.Context) ([]Tenant, error) {
	rows, err := q.db.QueryContext(ctx, getTenants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Domain,
			&i.Settings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, first_name, last_name, is_active, tenant_id, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, first_name, last_name, is_active, tenant_id, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDefaultTenant = `-- name: GetUserDefaultTenant :one
SELECT t.id, t.name, t.slug, t.domain, t.settings, t.is_active, t.created_at, t.updated_at FROM tenants t 
JOIN user_tenants ut ON t.id = ut.tenant_id 
WHERE ut.user_id = $1 AND ut.is_active = true 
ORDER BY ut.created_at LIMIT 1
`

func (q *Queries) GetUserDefaultTenant(ctx context.Context, userID uuid.UUID) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, getUserDefaultTenant, userID)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.tenant_id, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTenant = `-- name: GetUserTenant :one
SELECT user_id, tenant_id, role_id, is_active, created_at FROM user_tenants WHERE user_id = $1 AND tenant_id = $2
`

type GetUserTenantParams struct {
	UserID   uuid.UUID `json:"user_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetUserTenant(ctx context.Context, arg GetUserTenantParams) (UserTenant, error) {
	row := q.db.QueryRowContext(ctx, getUserTenant, arg.UserID, arg.TenantID)
	var i UserTenant
	err := row.Scan(
		&i.UserID,
		&i.TenantID,
		&i.RoleID,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const getUserTenants = `-- name: GetUserTenants :many
SELECT t.id, t.name, t.slug, t.domain, t.settings, t.is_active, t.created_at, t.updated_at FROM tenants t 
JOIN user_tenants ut ON t.id = ut.tenant_id 
WHERE ut.user_id = $1 AND ut.is_active = true 
ORDER BY ut.created_at
`

func (q *Queries) GetUserTenants(ctx context.Context, userID uuid.UUID) ([]Tenant, error) {
	rows, err := q.db.QueryContext(ctx, getUserTenants, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Domain,
			&i.Settings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithTenant = `-- name: GetUserWithTenant :one
SELECT u.id, u.email, u.password_hash, u.first_name, u.last_name, u.is_active, u.tenant_id, u.created_at, u.updated_at, t.name as tenant_name, t.slug as tenant_slug 
FROM users u 
JOIN tenants t ON u.tenant_id = t.id 
WHERE u.id = $1
`

type GetUserWithTenantRow struct {
	ID           uuid.UUID      `json:"id"`
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	IsActive     sql.NullBool   `json:"is_active"`
	TenantID     uuid.NullUUID  `json:"tenant_id"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	TenantName   string         `json:"tenant_name"`
	TenantSlug   string         `json:"tenant_slug"`
}

func (q *Queries) GetUserWithTenant(ctx context.Context, id uuid.UUID) (GetUserWithTenantRow, error) {
	row := q.db.QueryRowContext(ctx, getUserWithTenant, id)
	var i GetUserWithTenantRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TenantName,
		&i.TenantSlug,
	)
	return i, err
}

const getUsersByTenant = `-- name: GetUsersByTenant :many
SELECT id, email, password_hash, first_name, last_name, is_active, tenant_id, created_at, updated_at FROM users WHERE tenant_id = $1 ORDER BY email
`

// Enhanced User Queries with Tenant Support
func (q *Queries) GetUsersByTenant(ctx context.Context, tenantID uuid.NullUUID) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FirstName,
			&i.LastName,
			&i.IsActive,
			&i.TenantID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromTenant = `-- name: RemoveUserFromTenant :exec
DELETE FROM user_tenants WHERE user_id = $1 AND tenant_id = $2
`

type RemoveUserFromTenantParams struct {
	UserID   uuid.UUID `json:"user_id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) RemoveUserFromTenant(ctx context.Context, arg RemoveUserFromTenantParams) error {
	_, err := q.db.ExecContext(ctx, removeUserFromTenant, arg.UserID, arg.TenantID)
	return err
}

const updateAPIKey = `-- name: UpdateAPIKey :one
UPDATE api_keys SET name = $2, is_active = $3, expires_at = $4, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, user_id, name, key_hash, is_active, expires_at, last_used_at, created_at, updated_at
`

type UpdateAPIKeyParams struct {
	ID        uuid.UUID    `json:"id"`
	Name      string       `json:"name"`
	IsActive  sql.NullBool `json:"is_active"`
	ExpiresAt sql.NullTime `json:"expires_at"`
}

func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRowContext(ctx, updateAPIKey,
		arg.ID,
		arg.Name,
		arg.IsActive,
		arg.ExpiresAt,
	)
	var i ApiKey
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.KeyHash,
		&i.IsActive,
		&i.ExpiresAt,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE api_keys SET last_used_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateAPIKeyLastUsed, id)
	return err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections 
SET display_name = $2, description = $3, icon = $4, updated_at = CURRENT_TIMESTAMP, updated_by = $5
WHERE id = $1 RETURNING id, name, display_name, description, icon, is_system, tenant_id, created_by, updated_by, created_at, updated_at
`

type UpdateCollectionParams struct {
	ID          uuid.UUID      `json:"id"`
	DisplayName sql.NullString `json:"display_name"`
	Description sql.NullString `json:"description"`
	Icon        sql.NullString `json:"icon"`
	UpdatedBy   uuid.NullUUID  `json:"updated_by"`
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRowContext(ctx, updateCollection,
		arg.ID,
		arg.DisplayName,
		arg.Description,
		arg.Icon,
		arg.UpdatedBy,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
		&i.Icon,
		&i.IsSystem,
		&i.TenantID,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateField = `-- name: UpdateField :one
UPDATE fields 
SET display_name = $2, type = $3, is_primary = $4, is_required = $5, is_unique = $6, default_value = $7, validation_rules = $8, relation_config = $9, sort_order = $10, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 RETURNING id, collection_id, name, display_name, type, is_primary, is_required, is_unique, default_value, validation_rules, sort_order, relation_config, tenant_id, created_at, updated_at
`

type UpdateFieldParams struct {
	ID              uuid.UUID             `json:"id"`
	DisplayName     sql.NullString        `json:"display_name"`
	Type            string                `json:"type"`
	IsPrimary       sql.NullBool          `json:"is_primary"`
	IsRequired      sql.NullBool          `json:"is_required"`
	IsUnique        sql.NullBool          `json:"is_unique"`
	DefaultValue    sql.NullString        `json:"default_value"`
	ValidationRules pqtype.NullRawMessage `json:"validation_rules"`
	RelationConfig  pqtype.NullRawMessage `json:"relation_config"`
	SortOrder       sql.NullInt32         `json:"sort_order"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) (Field, error) {
	row := q.db.QueryRowContext(ctx, updateField,
		arg.ID,
		arg.DisplayName,
		arg.Type,
		arg.IsPrimary,
		arg.IsRequired,
		arg.IsUnique,
		arg.DefaultValue,
		arg.ValidationRules,
		arg.RelationConfig,
		arg.SortOrder,
	)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.Name,
		&i.DisplayName,
		&i.Type,
		&i.IsPrimary,
		&i.IsRequired,
		&i.IsUnique,
		&i.DefaultValue,
		&i.ValidationRules,
		&i.SortOrder,
		&i.RelationConfig,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions 
SET field_filter = $2, allowed_fields = $3, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 RETURNING id, role_id, table_name, action, field_filter, allowed_fields, tenant_id, created_at, updated_at
`

type UpdatePermissionParams struct {
	ID            uuid.UUID             `json:"id"`
	FieldFilter   pqtype.NullRawMessage `json:"field_filter"`
	AllowedFields []string              `json:"allowed_fields"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, updatePermission, arg.ID, arg.FieldFilter, pq.Array(arg.AllowedFields))
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.TableName,
		&i.Action,
		&i.FieldFilter,
		pq.Array(&i.AllowedFields),
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTenant = `-- name: UpdateTenant :one
UPDATE tenants SET name = $2, slug = $3, domain = $4, settings = $5, updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id, name, slug, domain, settings, is_active, created_at, updated_at
`

type UpdateTenantParams struct {
	ID       uuid.UUID             `json:"id"`
	Name     string                `json:"name"`
	Slug     string                `json:"slug"`
	Domain   sql.NullString        `json:"domain"`
	Settings pqtype.NullRawMessage `json:"settings"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (Tenant, error) {
	row := q.db.QueryRowContext(ctx, updateTenant,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Domain,
		arg.Settings,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Domain,
		&i.Settings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET email = $2, first_name = $3, last_name = $4, is_active = $5, updated_at = CURRENT_TIMESTAMP 
WHERE id = $1 RETURNING id, email, password_hash, first_name, last_name, is_active, tenant_id, created_at, updated_at
`

type UpdateUserParams struct {
	ID        uuid.UUID      `json:"id"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	IsActive  sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.IsActive,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FirstName,
		&i.LastName,
		&i.IsActive,
		&i.TenantID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
